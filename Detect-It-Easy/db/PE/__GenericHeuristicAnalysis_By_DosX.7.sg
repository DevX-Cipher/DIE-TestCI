// Detect It Easy: detection rule file

/*
             ██████╗ ███████╗███╗   ██╗███████╗██████╗ ██╗ ██████╗
            ██╔════╝ ██╔════╝████╗  ██║██╔════╝██╔══██╗██║██╔════╝
            ██║  ███╗█████╗  ██╔██╗ ██║█████╗  ██████╔╝██║██║
            ██║   ██║██╔══╝  ██║╚██╗██║██╔══╝  ██╔══██╗██║██║
            ╚██████╔╝███████╗██║ ╚████║███████╗██║  ██║██║╚██████╗
             ╚═════╝ ╚══════╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝ ╚═════╝
  ██╗    ██╗  ██╗███████╗██╗   ██╗██████╗ ██╗███████╗████████╗██╗ ██████╗    ██╗
 ██╔╝    ██║  ██║██╔════╝██║   ██║██╔══██╗██║██╔════╝╚══██╔══╝██║██╔════╝    ╚██╗
██╔╝     ███████║█████╗  ██║   ██║██████╔╝██║███████╗   ██║   ██║██║          ╚██╗
╚██╗     ██╔══██║██╔══╝  ██║   ██║██╔══██╗██║╚════██║   ██║   ██║██║          ██╔╝
 ╚██╗    ██║  ██║███████╗╚██████╔╝██║  ██║██║███████║   ██║   ██║╚██████╗    ██╔╝
  ╚═╝    ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝  ╚═╝╚═╝╚══════╝   ╚═╝   ╚═╝ ╚═════╝    ╚═╝
           █████╗ ███╗   ██╗ █████╗ ██╗  ██╗   ██╗███████╗██╗███████╗
          ██╔══██╗████╗  ██║██╔══██╗██║  ╚██╗ ██╔╝██╔════╝██║██╔════╝
          ███████║██╔██╗ ██║███████║██║   ╚████╔╝ ███████╗██║███████╗
          ██╔══██║██║╚██╗██║██╔══██║██║    ╚██╔╝  ╚════██║██║╚════██║
          ██║  ██║██║ ╚████║██║  ██║███████╗██║   ███████║██║███████║
          ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝╚══════╝╚═╝   ╚══════╝╚═╝╚══════╝
*/

//    ┌─────────────────────────┤ ABOUT ├─────────────────────────┐
//    │    This heuristic analysis helps detect the presence of   │
//    │    obfuscation, packers, licensing systems, debugging     │
//    │    information, file integrity issues, or even potential  │
//    │    malicious code using advanced and complex checks. It   │
//    │    includes pinpoint scanning, intelligent inspections,   │
//    │    signature-based analysis, thorough file content        │
//    │    evaluation, and much more! >:)                         │
//    └───────────────────────────────────────────────────────────┘

//    ┌─────────────────────────┤ DONATE ├────────────────────────┐
//    │     ┌ Did you like my work? :D Thank you! But what        │
//    │     │ about donation? I'll be very grateful <3            │
//    │     └─┐                                                   │
//    │       ├─ Payeer: P1066822521                              │
//    │       │                   └─ Any amount                   │
//    │       │                                                   │
//    │       ├─ BTC:   37uRiHBqK3QiJ2jamqmmk1Q3sCmAmWngcC        │
//    │       │                   └─ 0.0005 BTC minimum           │
//    │       │                                                   │
//    │       ├─ LTC:   MCwRK1Z7K4GYHt9ZrbTR2SMCEqzqQaTbRF        │
//    │       │                   └─ 0.0010 LTC minimum           │
//    │       │                                                   │
//    │       └─ USDT:  TUVH7QkcZws78QMC3XyAwfuzxUbaeLnfAC        │
//    │          TRC-20 ─┘        └─ 5 USDT minimum               │
//    └───────────────────────────────────────────────────────────┘

//    ┌────────────────────────┤ CONTACTS ├───────────────────────┐
//    │      ┌ Author is DosX                                     │
//    │      └┬─ E-Mail: collab@kay-software.ru                   │
//    │       ├─ GitHub: https://github.com/DosX-dev              │
//    │       └─ Telegram: @DosX_dev                              │
//    ├───────────────────────────────────────────────────────────┤
//    │     If I don't respond to email, message to Telegram      │
//    └───────────────────────────────────────────────────────────┘

//         ┌───────────────────────────────────────────────┐
//         │   For the module to work correctly, official  │
//         │   Detect It Easy components are recommended   │
//         ├───────────────────────────────────────────────┘
//         └─┐
//           └──  Please don't read the code out loud
//                unless you have exorcism skills

const logType = {
    warning: -2,
    about: -1,
    nothing: 0,
    any: 1,
    net: 2
},
    heurLabel = "HEUR";

var lastOffsetDetected = "0x00";

function detect() { main(); }

function main() {
    if (stubForWrongEnvironment()) return null; // 'PE' is undefined
    if (stubForLegacyEngines()) return null; // old DIE version

    if (PE.isHeuristicScan()) {
        if (!PE.isVerbose()) {
            log(logType.warning, "To get the full heuristic scan result use '--verbose'");
        }

        log(logType.about, "Generic Heuristic Analysis by DosX (@DosX_dev)");

        log(logType.nothing, "Scanning has begun!");

        if (PE.isNet()) {
            scanForObfuscations_NET();
            scanForAntiAnalysis_NET();
        } else {
            scanForObfuscations_Native();
        }

        scanForPackersAndCryptors_NET_and_Native();
        scanForLicensingSystems_NET_and_Native();
        scanForBadFileFormat_NET_and_Native();
        scanForDebugData_NET_and_Native();
        scanForMaliciousCode_NET_and_Native();

        if (PE.isVerbose()) {
            scanForLanguages_NET_and_Native();
        }

        // >> Happy end <<
        log(logType.nothing, "Scan completed.");
    } else {
        log(logType.warning, "Heuristic scan is disabled. Use '--heuristicscan' to enable");
    }
}



function stubForLegacyEngines() {
    if (typeof PE.getNetAssemblyName === "undefined") {
        stdout(">>> Update DIE Engine to 3.11 and higher for using Heuristic-analyser by DosX <<<");
        return true;
    }

    return false;
}



function stubForWrongEnvironment() {
    if (typeof PE === "undefined") {
        stdout(">>> Wrong environment! 'PE' is undefined. Check DIE-engine for correct installation <<<");
        return true;
    }

    return false;
}



/**
 * Outputs a warning message to the appropriate output stream.
 *
 * Depending on the environment, this function will:
 * - Use `console.warn` if `console` is available.
 * - Use `_setResult` if `File` is available.
 * - Use `_error` if it is defined as a function.
 * - Throw an error if none of the above conditions are met.
 *
 * @param {string} stringToOut - The warning message to output.
 */
function stdout(stringToOut) {
    if (typeof console === "object") {
        console.warn(stringToOut);
    } else if (typeof File === "object") {
        _setResult("~warning", stringToOut, String(), String());
    } else {
        if (typeof _error === "function") {
            _error(stringToOut);
        } else {
            throw stringToOut;
        }
    }
}



function scanForObfuscations_NET() {
    var options = String();

    var isDetected = Boolean();




    const isVbNet = isVbNetStandartLibraryPresent();




    // Is managed entry point modified? Let's check it using default .NET EP names

    var isEntryPointModified = false;

    const vbNetEntries = [
        "Main",
        "main",
        "MAIN",
        "MyApplication"
    ], defaultEntries = [ // like MSIL, C#, C++ NET etc
        "Main",
        "main", // F# entry
        "main@", // F# entry
        "<Main>$", // For programs with top-level operators (C#)
        "mainCRTStartup", // C++ CLR .NET (CLI)
        "wWinMainCRTStartup", // C++ CLR .NET (GUI)
        "_WinMainCRTStartup"
    ]

    if (!PE.isDll()) {
        if (isVbNet) {
            if (isAllNetReferencesMissing(vbNetEntries)) {
                isEntryPointModified = true;
            }
        } else if (isAllNetReferencesMissing(defaultEntries)) {
            isEntryPointModified = true;
        }

        if (isEntryPointModified) {
            log(logType.net, "No \"Main\" method found")
        }
    }

    if (isEntryPointModified) options = "Modified managed EP";




    // <Module>.cctor can execute code before the Main method is called 

    var isNetCctorPresent = false;

    if (PE.isNetGlobalCctorPresent() && !isCppClrLikeApp()) {
        log(logType.net, "Global constructor detected!");
        isNetCctorPresent = true;
    }

    if (isNetCctorPresent) options += (options ? " + " : String()) + "CLR constructor";




    // If .NET meta headers are not present in the default .NET section, then the file is mutant

    var isStrangeEpPosition = false;

    const netMetaHeaders = [
        "~",
        "Strings",
        "US",
        "GUID",
        "Blob"
    ];

    // Specify the default .NET section index
    const defaultNetSection = 0;

    // Check conditions for a strange entry point position (not for CLR apps)
    if (!PE.isDll() && PE.getNumberOfSections() > 1 && !isCppClrLikeApp()) {
        // Iterate through .NET metadata headers
        for (var s = 0; s < netMetaHeaders.length; s++) {
            const headerName = netMetaHeaders[s];

            // Check if the signature is not present in the default .NET section
            if (!PE.isSignatureInSectionPresent(defaultNetSection, "00'#" + headerName + "'00")) {
                isStrangeEpPosition = true;
                break;
            }
        }
    }

    if (isStrangeEpPosition) options += (options ? " + " : String()) + "Strange EP position";




    // .NET files has a specific pattern of the entry point

    var isNativeEntryPointModified = false;

    if (!PE.isDll() && !isCppClrLikeApp()) { // not for CLR apps
        if (!PE.is64()) {
            // FF2500????00: jmp dword ptr [ ... ]
            const firstOpCode = getFirstEpAsmOpCode();

            if (firstOpCode !== "JMP") {
                if (PE.VAToOffset(PE.getAddressOfEntryPoint()) !== -1) {
                    log(logType.net, "Very strange EP pattern: " + getEpAsmPattern(onlyOpCodes = true, numberOf = 4).split("|").join(" .. "));
                } else {
                    log(logType.net, "No native entry point");
                }

                isNativeEntryPointModified = true;
            }
        } else { // AMD64
            if (PE.VAToOffset(PE.getAddressOfEntryPoint()) !== 0x00) {
                isNativeEntryPointModified = true;
            }
        }
    }

    if (isNativeEntryPointModified) options += (options ? " + " : String()) + "Modified native EP";




    // Check if the specified DOS message is not found in the DOS stub

    var isDosMessageModified = false;

    if (PE.findSignature(PE.getDosStubOffset(), PE.getDosStubSize(), "'This program cannot be run in DOS mode.'") === -1) {
        log(logType.net, "DOS-stub modified!");
        isDosMessageModified = true;
    }

    if (isDosMessageModified) options += (options ? " + " : String()) + "Modified DOS";




    // Check PE image for strange sections

    var isStrangeSectionsPresent = false;

    const badChars = '_-=+~!@#$%^&*()"№;%:?*():;,/\\|\'`<>.0123456789'; // Very very bad!

    if (PE.getNumberOfSections() > (!isCppClrLikeApp() ? 6 : 10) || !PE.section[".text"]) { isStrangeSectionsPresent = true; } else {
        // Iterate through each section
        for (var i = 0; i < PE.getNumberOfSections() && !isStrangeSectionsPresent; i++) {
            const sectionName = PE.getSectionName(i);

            // Check if the first character is not "." and the length of name is less than 3
            if (sectionName[0] !== "." && sectionName.length < 3) {
                isStrangeSectionsPresent = true;
                break;
            }

            // Iterate through characters after "."
            // Check if the character is in the badChars list
            for (var d = 0; d < badChars.length && !isStrangeSectionsPresent; d++) {
                if (sectionName.substr(1, sectionName.length).indexOf(badChars[d]) !== -1) {
                    isStrangeSectionsPresent = true;
                }
            }

            if (!isAnsiString(sectionName) && !isStrangeSectionsPresent) {
                isStrangeSectionsPresent = true;
            }
        }
    }

    if (isStrangeSectionsPresent) options += (options ? " + " : String()) + "Strange sections";




    const opCodes = new NetOpCodes();




    // A popular way to obfuscate numbers/booleans

    var isIntConfusionPresent = false;

    const intConfusionXorPattern = opCodes.ldc_i4 + opCodes.ldc_i4 + opCodes.xor + opCodes.ldc_i4;

    if (validateNetByteCode(intConfusionXorPattern)) {
        if (validateNetByteCode( // samples by: Inx Obfuscator
            intConfusionXorPattern +
            (opCodes.setStrict(opCodes.bne_un_s, "09") + opCodes.ldc_i4_2 + opCodes.stloc_0 + opCodes.sizeof + opCodes.add)
        ) ||
            validateNetByteCode( // samples by: MindLated, NetShield
                intConfusionXorPattern +
                (opCodes.bne_un + opCodes.ldc_i4 + opCodes.stloc + opCodes.sizeof + opCodes.add)
            ) ||
            validateNetByteCode( // samples by: VavilonProtect
                intConfusionXorPattern +
                (opCodes.bne_un + opCodes.ldc_i4_2 + opCodes.stloc_s + opCodes.sizeof + opCodes.add)
            )
        ) {
            log(logType.net, "Int confusion detected! Offset: " + lastOffsetDetected);
            isIntConfusionPresent = true;
        }
    }

    if (isIntConfusionPresent) options += (options ? " + " : String()) + "Int confusion";




    // Virtualization is a method of protection in which some code segments are rewritten into instructions inherent in the built-in virtual machine and executed by it

    var isVirtualizationPresent = false;

    if (
        isAllNetReferencesPresent(
            references = [
                "System.Reflection", // System.Reflection.dll
                "GetILGenerator", // MSIL: 'System.Reflection.Emit.DynamicMethod::GetILGenerator()'
                "BeginInvoke",
                "EndInvoke",
                "OpCode" // MSIL: 'System.Reflection.Emit.OpCode'
            ]
        ) &&
        (
            PE.isNetObjectPresent("Ldarg_0") || // MSIL: 'System.Reflection.Emit.OpCodes.Ldarg_0'
            PE.isNetObjectPresent("CreateDelegate") // MSIL: 'System.Delegate.CreateDelegate'
        ) && !isFrameworkComponent()
    ) {
        isVirtualizationPresent = true;
    }

    if (isVirtualizationPresent) options += (options ? " + " : String()) + "Virtualization";




    // Hiding calls using delegate tricks

    var callsEncrypt = false;

    if (
        isAllNetReferencesPresent(
            references = [
                "GetTypeFromHandle", // MSIL: 'System.Type::GetTypeFromHandle( ... )'
                "BinaryReader", // MSIL: 'System.IO.BinaryReader'
                "CreateDelegate", // MSIL: '[Delegate].CreateDelegate'
                "MakeByRefType", // MSIL: 'System.Type::MakeByRefType()'
                "DynamicMethod" // MSIL: 'System.Reflection.Emit.DynamicMethod'
            ]
        ) && !isFrameworkComponent()
    ) {
        callsEncrypt = true;
    }

    if (callsEncrypt) options += (options ? " + " : String()) + "Calls encrypt";




    // https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.suppressildasmattribute

    var isAntiIldasmPresent = false;

    if (validateNetObject("SuppressIldasmAttribute")) {
        isAntiIldasmPresent = true;
    }

    if (isAntiIldasmPresent) options += (options ? " + " : String()) + "Anti-ILDASM";




    // Anti de4dot via inheritance

    var isAntiDe4dotPresent = false;

    if (
        validateSignature("'Form'******00'Form'******00'Form'******00") || // samples by: NetShield
        validateNetObject("Form0") // samples by: MindLated
    ) {
        log(logType.net, "File may be protected by de4dot!");
        isAntiDe4dotPresent = true;
    }

    if (isAntiDe4dotPresent) options += (options ? " + " : String()) + "Anti-de4dot";




    // An obfuscation method in which calli is used instead of regular calls

    var isCalliInvokesPresent = false;

    if (validateNetByteCode( // samples by: MindLated
        opCodes.setStrict(opCodes.ldftn, "** ?? 00 0A") +
        opCodes.setStrict(opCodes.calli, "** 00 00 11")
    ) ||
        validateNetByteCode( // samples by: ArmDot, DarksProtector
            opCodes.ldelem_i +
            opCodes.setStrict(opCodes.calli, "** 00 00 11")
        )) {
        log(logType.net, "Calli invokes detected! Offset: " + lastOffsetDetected);
        isCalliInvokesPresent = true;
    }

    if (isCalliInvokesPresent) options += (options ? " + " : String()) + "Calli invokes";




    // An obfuscation method that uses ldftn to create pointers to methods, which are then used in the code

    var isLdftnPointersPresent = false;

    if (validateNetByteCode(
        opCodes.nop + opCodes.setStrict(opCodes.ldftn, "** 00 00 06") + opCodes.stelem_i
    ) ||
        validateNetByteCode(
            opCodes.nop + opCodes.setStrict(opCodes.ldftn, "** 00 00 0A") + opCodes.stelem_i
        ) ||
        validateNetByteCode( // samples by: Quantum (private)
            opCodes.setStrict(opCodes.ldftn, "** 00 00 0A") +
            opCodes.setStrict(opCodes.calli, "** 00 00 11")
        )) {
        log(logType.net, "Ldftn pointers method-obfuscation detected! Offset: " + lastOffsetDetected);
        isLdftnPointersPresent = true;
    }

    if (isLdftnPointersPresent) options += (options ? " + " : String()) + "Ldftn pointers";




    // Turns the code into spaghetti by splitting it into blocks that it executes depending on the situation

    var isCtrlFlowPresent = false;

    if (
        validateNetByteCode( // samples by: ConfuserEx
            opCodes.nop + opCodes.ldloc_0 + opCodes.ldc_i4 + opCodes.mul + opCodes.ldc_i4 + opCodes.xor + opCodes.br_s +
            opCodes.nop + opCodes.ldloc_0 + opCodes.ldc_i4 + opCodes.mul + opCodes.ldc_i4 + opCodes.xor + opCodes.br_s
        ) ||
        validateNetByteCode( // samples by: ConfuserEx (neo mod)
            opCodes.ldc_i4 + opCodes.ldc_i4 + opCodes.xor + opCodes.dup + opCodes.stloc_0 + opCodes.ldc_i4_3 + opCodes.rem_un + opCodes.switch__nobody
        ) ||
        validateNetByteCode( // samples by: .NET Reactor (v6.9.8)
            opCodes.setStrict(opCodes.ldc_i4, "00 00 00 00") + opCodes.br + opCodes.br + opCodes.ldloc
        ) ||
        validateNetByteCode( // samples by: .NET Reactor
            opCodes.ldsfld + opCodes.brfalse + opCodes.pop +
            opCodes.setStrict(opCodes.ldc_i4, "01 00 00 00") + // MSIL: 'ldc.4 1'
            opCodes.br + opCodes.nop
        ) ||
        validateNetByteCode( // samples by: .NET Reactor
            opCodes.setNullValue(opCodes.ldc_i4) +
            opCodes.ldsfld + opCodes.brtrue + opCodes.pop + opCodes.ldc_i4 +
            opCodes.br
        ) ||
        validateNetByteCode( // samples by: .NET Reactor (legacy~~)
            opCodes.stloc + opCodes.ldloc +
            opCodes.joinNoBodyAndValue(opCodes.switch__nobody, "** ** ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 00 00", "switch__nobody") +
            opCodes.ldc_i4 + opCodes.br
        ) ||
        validateNetByteCode( // Crypto Obfuscator
            opCodes.ldc_i4_3 + opCodes.joinNoBodyAndValue(opCodes.switch__nobody, "01 00 00 00 F6 FF FF FF") + opCodes.ldc_i4_1 + opCodes.brtrue_s + opCodes.ldtoken + opCodes.pop
        ) ||
        validateNetByteCode( // samples by: MindLated, NetShield
            opCodes.setNullValue(opCodes.ldc_i4) + // MSIL: 'ldc.i4 0'
            opCodes.stloc + opCodes.br + opCodes.nop + opCodes.ldloc +
            opCodes.setStrict(opCodes.ldc_i4, "01 00 00 00") + // MSIL: 'ldc.i4 1'
            opCodes.ceq + opCodes.brfalse
        ) ||
        validateNetByteCode( // samples by: Rose Obfuscator
            opCodes.setNullValue(opCodes.ldc_i4) + // MSIL: 'ldc.i4'
            opCodes.stloc + opCodes.br + opCodes.nop + opCodes.ldloc + opCodes.ldc_i4 + opCodes.ceq + opCodes.brfalse
        ) ||
        validateNetByteCode( // samples by: Smart Assembly
            opCodes.ldc_i4 + opCodes.br + opCodes.ldloc_s + opCodes.ldc_i4_s + opCodes.ldc_i4_0 + opCodes.stelem_i1 +
            opCodes.ldc_i4 + opCodes.br
        ) ||
        validateNetByteCode( // samples by: ConfuserEx (Beds mod)
            opCodes.ldc_i4 + opCodes.ldc_i4 + opCodes._unknown + opCodes.ldc_i4 + opCodes._unknown + opCodes.stloc_0 + opCodes.nop + opCodes.ldloc_0 +
            opCodes.ldc_i4 + opCodes.ldc_i4 + opCodes._unknown + opCodes.ldc_i4 + opCodes._unknown + opCodes.ceq + opCodes.brfalse_s
        ) ||
        validateNetByteCode( // samples by: DotNetPatcher
            opCodes.setStrict(opCodes.stloc_s, "05") + opCodes.nop + opCodes.ldloc_s + opCodes._unknown + opCodes.ceq + opCodes.brfalse_s + opCodes._unknown +
            opCodes.setStrict(opCodes.stloc_s, "05") + opCodes.nop + opCodes.ldloc_s + opCodes._unknown + opCodes.ceq + opCodes.brfalse_s
        ) ||
        validateNetByteCode( // samples by: VMProtect
            opCodes.ldloc_0 + opCodes.setStrict(opCodes.ldc_i4, "?? ** ** **") + opCodes._unknown + opCodes.stloc_0 +
            opCodes.ldloc_0 + opCodes.setStrict(opCodes.ldc_i4, "?? ** ** **") + opCodes.xor + opCodes.stloc_0
        ) ||
        validateNetByteCode( // samples by: VMProtect
            opCodes.setStrict(opCodes.ldc_i4, "?? ** ** **") + opCodes._unknown + opCodes.stloc_0 + opCodes.setStrict(opCodes.ldftn, "** ?? ?? ??")
        )
    ) {
        log(logType.net, "Control flow obfuscation detected! Offset: " + lastOffsetDetected);
        isCtrlFlowPresent = true;
    }

    if (isCtrlFlowPresent) options += (options ? " + " : String()) + "Ctrl flow";




    const afterCtorOffset = PE.findSignature(PE.getDosStubOffset() + PE.getDosStubSize(), PE.getSize() - PE.getOverlaySize(), "'<Module>'00**") + 8;




    // Indicates that the file uses short object names. Typically this indicates the presence of an obfuscation
    // There are two ways to detect short names - find one-letter objects or just use signature mask at Ctor offset :D

    var isShortNamesPresent = false;

    if (PE.compare("00**00**00", afterCtorOffset) ||
        PE.compare("00****00****00****00", afterCtorOffset) ||
        PE.compare("00******00******00******00", afterCtorOffset) ||
        PE.compare("00********00********00********00", afterCtorOffset) ||
        PE.compare("00****00****00", afterCtorOffset) ||
        PE.compare("00****00**00", afterCtorOffset) ||
        PE.compare("00**00****00", afterCtorOffset)) {
        log(logType.net, "Short names detected! (mask)");
        isShortNamesPresent = true;
    }

    if (!isShortNamesPresent && PE.compare("00**00", afterCtorOffset)) { // the second way :D
        var shortNamesFound = 0;

        const chars = "QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm";

        for (var i in chars) {
            if (i > 0 && !isShortNamesPresent) {
                if (PE.isNetObjectPresent(chars[i])) {
                    shortNamesFound++;
                    log(logType.net, "Short name found: '" + chars[i] + "' (" + shortNamesFound + "/20)");
                }

                if (shortNamesFound === 20) {
                    isShortNamesPresent = true;
                }
            }
        }
    }

    if (isShortNamesPresent) options += (options ? " + " : String()) + "Short names";




    // Scan for strange patterns after <Module> .ctor (like "a1b2c3d4e5f6g7h8i9j0")

    var badNamings = false;

    var buffer = "";

    // get next 0x12c bytes after <Module> .ctor
    for (var i = 0; i < 0x12c; i++) {
        var currentByte = PE.readByte(afterCtorOffset + i).toString(16);

        if (currentByte === '0') currentByte += '0';

        buffer += currentByte;
        buffer += ' ';
    }

    var bufferString = String();

    // 0x00 to [0x20, 0x20, 0x20]
    const bufferArray = replaceAllInString(buffer, '00 ', '20 20 20 ').split(' ');

    // buffer to a string
    for (var i = 0; i < bufferArray.length; i++)
        bufferString += String.fromCharCode(parseInt(bufferArray[i], 16));


    const patternsToExplore = bufferString.split("   ");

    var strangePatternsCounter = 0;

    for (var i = 0; i < patternsToExplore.length && !badNamings; i++) {

        const currentStringPattern = patternsToExplore[i];

        if (PE.isNetObjectPresent("<PrivateImplementationDetails>") && currentStringPattern.length === 40) {
            break;
        }

        if (currentStringPattern.indexOf("<") === -1 && isNameObfuscated(currentStringPattern))
            strangePatternsCounter++;

        if (strangePatternsCounter > 2)
            badNamings = true;

    }

    if (badNamings) options += (options ? " + " : String()) + "Bad namings";




    // AntiTamper protects the file from modification

    var isAntiTamperPresent = false;

    if (
        validateNetUnicodeString(" is tampered.") || // samples by: .NET Reactor
        validateNetUnicodeString("ping 127.0.0.1 > nul") || // samples by: ConfuserEx (Trinity, SkiDzEx like)
        validateNetUnicodeString("/C ping 1.1.1.1 -n 1 -w 3000 > Nul & Del \"") || // samples by: MindLated
        validateNetUnicodeString( // samples by: ConfuserEx
            opCodes.ldloc_s + opCodes.ldc_i4_0 + opCodes.ldloc_s + opCodes.ldc_i4_0 + opCodes.ldelem_u4 + opCodes.ldloc_s + opCodes.ldc_i4_0 + opCodes.ldelem_u4 + opCodes._unknown + opCodes.stelem_i4 +
            opCodes.ldloc_s + opCodes.ldc_i4_1 + opCodes.ldloc_s + opCodes.ldc_i4_1 + opCodes.ldelem_u4 + opCodes.ldloc_s + opCodes.ldc_i4_1 + opCodes.ldelem_u4 + opCodes._unknown + opCodes.stelem_i4 +
            opCodes.ldloc_s + opCodes.ldc_i4_2 + opCodes.ldloc_s + opCodes.ldc_i4_2 + opCodes.ldelem_u4 + opCodes.ldloc_s + opCodes.ldc_i4_2 + opCodes.ldelem_u4 + opCodes._unknown + opCodes.stelem_i4 +
            opCodes.ldloc_s + opCodes.ldc_i4_3 + opCodes.ldloc_s + opCodes.ldc_i4_3 + opCodes.ldelem_u4 + opCodes.ldloc_s + opCodes.ldc_i4_3 + opCodes.ldelem_u4 + opCodes._unknown + opCodes.stelem_i4 +
            opCodes.ldloc_s + opCodes.ldc_i4_4 + opCodes.ldloc_s + opCodes.ldc_i4_4 + opCodes.ldelem_u4 + opCodes.ldloc_s + opCodes.ldc_i4_4 + opCodes.ldelem_u4 + opCodes._unknown + opCodes.stelem_i4
        ) ||
        validateNetByteCode( // samples: ConfuserEx (Beds mod, private)
            opCodes.ldloc_s + opCodes._unknown + opCodes.shr_un + opCodes.ldloc_s + opCodes.ldc_i4_s + opCodes.shl + opCodes.or + opCodes.stloc_s +
            opCodes.ldloc_s + opCodes._unknown + opCodes.shr_un + opCodes.ldloc_s + opCodes.ldc_i4_s + opCodes.shl + opCodes.or + opCodes.stloc_s +
            opCodes.ldloc_s + opCodes._unknown + opCodes.shr_un + opCodes.ldloc_s + opCodes.ldc_i4_s + opCodes.shl + opCodes.or + opCodes.stloc_s
        )
    ) {
        log(logType.net, "Anti-tamper detected!");
        isAntiTamperPresent = true;
    }

    if (isAntiTamperPresent) options += (options ? " + " : String()) + "Anti-tamper";




    // If in the assembly you can find the second object starting with “<Module>”, then this is a fakeee!

    var isModuleCtorMultiple = false;

    var currentCtorOffset = PE.findSignature(PE.getDosStubOffset() + PE.getDosStubSize(), PE.getSize() - PE.getOverlaySize(), "00'<Module>'00");

    if (currentCtorOffset !== -1) {
        var secondCtorNameOffset = PE.findSignature(currentCtorOffset + 10, PE.getSize() - PE.getOverlaySize(), "'<Module>'");

        if (secondCtorNameOffset !== -1 && PE.readByte(secondCtorNameOffset + 8) !== 0x00) {
            log(logType.net, "Fake <Module> detected! Offset: 0x" + Number(secondCtorNameOffset).toString(16));
            isModuleCtorMultiple = true;
        }
    }

    if (isModuleCtorMultiple) options += (options ? " + " : String()) + "Fake .cctor name";




    var isBadCctor = false;

    if (currentCtorOffset === -1) {
        log("It seems that the .cctor is missing. Bad PE format!");
        isBadCctor = true;
    }

    if (isBadCctor) options += (options ? " + " : String()) + "Bad .cctor format";




    // Detects the use of unusual mathematical expressions that would be simplified by the compiler. 
    // For example, an expression like "912874 + 39188124^834"

    var isMutationsPresent = false;

    const mathOpCodes = [
        opCodes.add, opCodes.sub,
        opCodes.mul, opCodes.div,
        opCodes.xor, opCodes.shr,
        opCodes.shl, opCodes.or,
        opCodes.not, opCodes.and
    ];

    const mathTemplates = [ // %s = math opcode
        opCodes.ldc_i4 + opCodes.ldc_i4 + "%s" + opCodes.stloc, // samples by: .NET Reactor
        opCodes.ldc_i4 + opCodes.ldc_i4 + "%s" + opCodes.ldsfld, // samples by: .NET Reactor
        opCodes.ldc_i4 + opCodes.ldc_i4 + "%s" + opCodes.ldc_i4 + opCodes.add, // samples by: ConfuserEx (Beds mod)
        opCodes.ldloc_1 + opCodes.ldc_i4 + opCodes.ldc_i4 + "%s" + opCodes.ldc_i4 + opCodes.ldc_i4, // samples by: SkiDzEX
        opCodes.ldloc + opCodes.ldc_i4 + opCodes.ldc_i4 + opCodes.ldc_i4 + "%s" + opCodes.stelem_i1, // samples by: .NET Reactor
        opCodes.ldc_i4 + opCodes.ldc_i4 + "%s" + opCodes.br_s // samples by: [Unknown protector, only samples]
    ];

    for (var y in mathTemplates) {
        if (!isMutationsPresent) {
            const template = mathTemplates[y];

            for (var e in mathOpCodes) {
                if (!isMutationsPresent) {
                    if (e == 0 && !validateNetByteCode(template.replace("%s", opCodes._unknown))) break; // No math mutations

                    const pattern = template.replace("%s", mathOpCodes[e]);

                    if (validateNetByteCode(pattern)) {
                        log(logType.net, "Math mutations detected! Offset: " + lastOffsetDetected);
                        isMutationsPresent = true;
                    }
                }
            }
        }
    }

    if (isMutationsPresent) options += (options ? " + " : String()) + "Math mutations";




    // VB NET apps with resources only

    var isStringsEncryptionPresent = false;

    if (isVbNet && !isFrameworkComponent()) {
        if (PE.isNetObjectPresent("Resources") && !validateGlobalUnicodeString(".Resources")) {
            isStringsEncryptionPresent = true;
        }
    }

    if (isStringsEncryptionPresent) options += (options ? " + " : String()) + "Strings encryption";




    // A type of obfuscation of numbers in which they are inverted several times from positive to negative and vice versa...
    var isMathInversionsPresent = false;

    if (validateNetByteCode(opCodes.ldc_i4 + opCodes.not) && (
        validateNetByteCode( // ~(-(~(-(~(-(~(-( num ))))))))
            opCodes.ldc_i4 +
            opCodes.not + opCodes.neg + opCodes.not + opCodes.neg +
            opCodes.not + opCodes.neg + opCodes.not + opCodes.neg
        ) ||
        validateNetByteCode( // ~(~(-(-(~(~( num ))))))
            opCodes.ldc_i4 +
            opCodes.not + opCodes.not + opCodes.neg + opCodes.neg +
            opCodes.not + opCodes.not
        ) ||
        validateNetByteCode( // ~(-(~(~(-(-( num ))))))
            opCodes.ldc_i4 +
            opCodes.not + opCodes.neg + opCodes.not + opCodes.not +
            opCodes.neg + opCodes.neg
        ) ||
        validateNetByteCode( // ~(-(~(-(~(~( num ))))))
            opCodes.ldc_i4 +
            opCodes.not + opCodes.neg + opCodes.not + opCodes.neg +
            opCodes.not + opCodes.not
        ) ||
        validateNetByteCode( // ~(-(~(-(~(-( num ))))))
            opCodes.ldc_i4 +
            opCodes.not + opCodes.neg + opCodes.not + opCodes.neg +
            opCodes.not + opCodes.neg
        )
    )) {
        log(logType.net, "Math inversions detected, offset " + lastOffsetDetected);
        isMathInversionsPresent = true;
    }

    if (isMathInversionsPresent) options += (options ? " + " : String()) + "Math inversions";




    // A technique that allows you to avoid code decompilation. dnSpy gives a parsing error when trying to open such a file

    var invalidOpCodes = false;

    if (
        /* validateNetByteCode( // samples by: SugarGuard
            opCodes.setStrict(opCodes.box, "?? 00 00 01") + opCodes.ret
        ) || */
        validateNetByteCode( // samples by: ConfuserEx (Beds mod)
            opCodes.setStrict(opCodes.calli, "FF FF FF FF") + opCodes.setStrict(opCodes.sizeof, "FF FF FF FF")
        )
    ) {
        log(logType, "Invalid OpCodes detected, offset " + lastOffsetDetected);
        invalidOpCodes = true;
    }

    if (invalidOpCodes) options += (options ? " + " : String()) + "Invalid OpCodes";




    // Some protections include their own dependencies in the form of runtime libraries

    var isProtectionRuntimePresent = false;

    var runtimeFound = String();

    const protectionsRuntime = [ // Need more
        { lib: "AgileDotNet.VMRuntime.dll", name: "Agile" },
        { lib: "Xerin.Runtime.dll", name: "XerinFuscator" },
        { lib: "Protect32.dll", name: "ILProtector" },
        { lib: "Protect64.dll", name: "ILProtector" },
        { lib: "OneVM.Runtime.dll", name: "OneVM" },
        { lib: "MRuntime3.dll", name: "Maxtocode" },
        { lib: "Attick.dll", name: "Maxtocode" },
        { lib: "HVMRuntm.dll", name: "DNGuard" }
    ];

    for (var i in protectionsRuntime) {
        const
            runtimeInfo = protectionsRuntime[i],
            runtimeLibraryName = runtimeInfo.lib,
            protectorName = runtimeInfo.name;

        if (PE.isNetObjectPresent(runtimeLibraryName) || // "runtime.dll"
            PE.isNetObjectPresent(runtimeLibraryName.substring(0, runtimeLibraryName.length - 4))) { // "runtime"
            log(logType.net, protectorName + " runtime detected!");
            isProtectionRuntimePresent = true;
            runtimeFound = protectorName;
            break;
        }
    }

    if (isProtectionRuntimePresent) options += (options ? " + " : String()) + runtimeFound + " runtime";




    const obfuscatorsAttributes = [
        "Xenocode.Client.Attributes.AssemblyAttributes.ProcessedByXenocode", // Xenocode
        "CryptoObfuscator.ProtectedWithCryptoObfuscatorAttribute", // Crypto Obfuscator
        "SecureTeam.Attributes.ObfuscatedByAgileDotNetAttribute", // Agile.NET
        "Xenocode.Client.Attributes.AssemblyAttributes", // Xenocode
        "SmartAssembly.Attributes.PoweredByAttribute", // Smart Assembly
        "ObfuscatedByAgileDotNetAttribute", // Agile.NET
        "NineRays.Obfuscator.Evaluation", // Spices.Net
        "ObfuscatedByCliSecureAttribute", // CliSecure
        "BabelObfuscatorAttribute", // Babel
        "AsStrongAsFuckAttribute", // AsStrongAsFuck
        "ProtectedByDotnetsafer", // DotNetSafer
        "Macrobject.Obfuscator", // Macrobject
        "DotfuscatorAttribute", // Dotfuscator
        "CodeWallTrialVersion", // CodeWall
        "ConfusedByAttribute", // ConfuserEx
        "ObfuscatedByGoliath", // Goliath
        "NETSpider.Attribute", // NETSpider
        "NineRays.Obfuscator", // Spices.Net
        "PoweredByAttribute", // Smart Assembly
        "RustemSoft.Skater", // Skater
        "BabelAttribute", // Babel
        "MRuntime3.dll", // Maxtocode
        "YanoAttribute", // Yano
        "EMyPID_8234_", // Eazfuscator.NET
        "ZYXDNGuarder", // DNGuard
        "SkiDzEX", // ConfuserEx based
        "Sixxpack", // Sixxpack
        "____KILL", // CodeVeil
        "Reactor", // Fake .NET Reactor
    ];

    var isFakeSignaturesPresent = false;

    var isWatermarkPresent = false;

    var signaturesCounter = 0;

    var obfuscatorAttributeFound = String();

    // Iterate through obfuscators attributes
    for (var t in obfuscatorsAttributes) {
        if (!isFakeSignaturesPresent) {
            if (validateNetObject(obfuscatorsAttributes[t])) {
                obfuscatorAttributeFound = obfuscatorsAttributes[t];
                signaturesCounter++;
            }

            // Check if the number of detected signatures exceeds 1
            if (signaturesCounter > 1) {
                // Set flag indicating the presence of fake signatures
                isFakeSignaturesPresent = true;
            }
        }
    }

    if (isFakeSignaturesPresent) {
        options += (options ? " + " : String()) + "Fake signatures";
    } else {
        // "Watermark" is only possible in the absence of fake signatures

        if (signaturesCounter === 1) {
            log(logType.nothing, "Watermark (Attribute) found: '" + obfuscatorAttributeFound + "'");
            isWatermarkPresent = true;
        }

        if ((!isWatermarkPresent && (
            validateSignature("'Obfuscated'") ||
            validateSignature("'obfuscated'") ||
            validateSignature("'ByAttribute'") ||
            validateSignature("'ObfuscatorAttribute'") ||
            validateNetObject("ObfuscationAttribute")
        )) && !isFrameworkComponent()) // System.Reflection.ObfuscationAttribute
        {
            isWatermarkPresent = true;
        }
    }

    if (isWatermarkPresent) options += (options ? " + " : String()) + "Watermark";




    // The module name must always contain the assembly name and the output file extension (Assembly "App", Module "App.dll").
    // If this standard is not followed, it means that the sample was modified after compilation.

    var isBuildInfoModified = false;

    var buildAssemblyName = PE.getNetAssemblyName(),
        buildModuleName = PE.getNetModuleName();

    if (buildAssemblyName.indexOf("Interop.") === 0) {
        buildAssemblyName = buildAssemblyName.substring(8, buildAssemblyName.length);
    }

    if (buildAssemblyName !== getFileNameWithoutExtension(buildModuleName) || buildAssemblyName === buildModuleName) {
        isBuildInfoModified = true;
    }

    if (isBuildInfoModified) options += (options ? " + " : String()) + "Modified build info";




    const protectorsLabelsToRemove = [ // Protectors with these names will be removed from results
        "SafeNet Sentinel LDK .NET",
        "Xenocode Postbuild",
        "Smart Assembly",
        "Dotfuscator",
        "Babel .NET",
        "Spices.Net",
        "Maxtocode",
        "FISH .NET",
        "CliSecure",
        "CodeWall",
        "CodeVeil",
        "Sixxpack",
        "DNGuard",
        "Goliath",
        "Agile",
        "Yano"
    ], packersLabelsToRemove = [
        "Quest PowerGUI",
        "DataAnubis",
        "NsPack",
        "ASPack"
    ], protectionsLabelsToRemove = [
        "Sentinel SuperPro dongle reference",
        "Unikey/Activator dongle reference",
        "Eutron SmartKey dongle reference",
        "SenseLock dongle reference",
        "Hardlock dongle reference",
        "WIBU Key dongle reference",
        "Wizzkey dongle reference",
        "SoftLok dongle reference",
        "NetHASP dongle reference"
    ];

    // Волки делают АУФ 🐺☝️

    if (isFakeSignaturesPresent) {
        for (var d in protectorsLabelsToRemove) {
            _removeResult("protector", protectorsLabelsToRemove[d]);
        }

        for (var d in packersLabelsToRemove) {
            _removeResult("cryptor", packersLabelsToRemove[d]);
            _removeResult("packer", packersLabelsToRemove[d]);
        }

        for (var d in protectionsLabelsToRemove) {
            _removeResult("protection", protectionsLabelsToRemove[d]);
        }
    }




    if (options.length != 0) isDetected = true;


    if (isDetected) {
        _setResult("~protection", "Obfuscation", String(), PE.isVerbose() ? options : String());
    }
}



function scanForAntiAnalysis_NET() {
    var options = String();

    var isDetected = false;


    // Assumes the file can detect debugging protection

    var isAntiDebugPresent = false;

    const debuggerObject = "Debugger", // MSIL: 'System.Diagnostics.Debugger' from System.Diagnostics.dll
        isAttached = "get_IsAttached", // MSIL: '*.Debugger::get_IsAttached()'
        isLogging = "IsLogging" // MSIL: '*.Debugger::IsLogging()'

    if (
        (
            ( // .NET Functions
                validateNetObject(debuggerObject) || validateNetUnicodeString(debuggerObject) // Check for 'Debugger'
            ) && (
                (validateNetObject(isAttached) || validateNetUnicodeString(isAttached)) || // Check for 'get_IsAttached' property
                (validateNetObject(isLogging) || validateNetUnicodeString(isLogging)) // Check for 'IsLogging' function
            ) ||
            ( // Native (WinAPI) functions
                validateNetObject("CheckRemoteDebuggerPresent") || validateNetObject("IsDebuggerPresent") ||
                validateNetObject("NtRemoveProcessDebug") || validateNetObject("NtQueryInformationProcess")
            )
        ) && !isFrameworkComponent()
    ) {
        isAntiDebugPresent = true;
    }

    if (isAntiDebugPresent) options += (options ? " + " : String()) + "Anti-debug";




    // A type of protection in which, after launching an application, it erases the headers and/or PE signature behind itself

    var isAntiDumpPresent = false;

    if (
        !isFrameworkComponent() && validateNetObject("VirtualProtect") && ( // from 'kernel32.dll', WinAPI
            // Need to check
            isAllNetReferencesPresent( // samples by: ConfuserEx, SkiDzEX
                references = [
                    "System.Runtime.InteropServices", // System.Runtime.InteropServices.dll
                    "Marshal", // MSIL: '*.Marshal::GetHINSTANCE( ... )'
                    "GetHINSTANCE", // MSIL: '*.Marshal::GetHINSTANCE( ... )'
                    "IntPtr", // MSIL: 'System.IntPtr'
                    "op_Explicit" // MSIL: 'System.IntPtr::op_Explicit'
                ]
            ) ||
            isAllNetReferencesPresent( // samples by: Inx Obfuscator
                references = [
                    "System.Diagnostics", // System.Diagnostics
                    "memcpy", // from 'msvcrt.dll', WinAPI
                    "IntPtr", // MSIL: 'System.IntPtr'
                    "get_MainModule", // MSIL: '*.Process::get_MainModule()'
                    "get_BaseAddress" // MSIL: '*.ProcessModule::get_BaseAddress()'
                ]
            ) ||
            isAllNetReferencesPresent( // samples by: MindLated
                references = [
                    "System.Runtime.InteropServices", // System.Runtime.InteropServices.dll
                    "Marshal", // MSIL: '*.Marshal::GetHINSTANCE( ... )'
                    "GetHINSTANCE", // MSIL: '*.Marshal::GetHINSTANCE( ... )'
                    "IntPtr", // MSIL: 'System.IntPtr'
                    "CopyBlock",
                    "InitBlock"
                ]
            )
        )
    ) {
        isAntiDumpPresent = true;
    }

    if (isAntiDumpPresent) options += (options ? " + " : String()) + "Anti-dump";




    const antiDnSpyTriggers = [
        "dnspy",
        "dnSpy",
        "DNSPY"
    ];

    var isAntiDnSpyPresent = false;

    // Iterate through anti-DnSpy triggers
    for (var l in antiDnSpyTriggers) {
        if (!isAntiDnSpyPresent) {
            const dnSpyName = antiDnSpyTriggers[l];

            // Check if the signature for anti-DnSpy trigger is valid using Unicode signature mask or the original signature
            if (
                validateGlobalUnicodeString(dnSpyName) ||
                validateSignature("'" + dnSpyName + "'")
            ) {
                // Set flag indicating the presence of anti-DnSpy behavior
                isAntiDnSpyPresent = true;
            }
        }
    }

    if (isAntiDnSpyPresent) options += (options ? " + " : String()) + "Anti-dnSpy";




    const antiIlSpyTriggers = [
        "ilspy",
        "ilSpy",
        "ILSpy",
        "ILSPY"
    ];

    var isAntiIlSpyPresent = false;

    for (var l in antiIlSpyTriggers) {
        if (!isAntiIlSpyPresent) {
            const ilSpyName = antiIlSpyTriggers[l];

            if (
                validateGlobalUnicodeString(ilSpyName) ||
                validateSignature("'" + ilSpyName + "'")
            ) {
                isAntiIlSpyPresent = true;
            }
        }
    }

    if (isAntiIlSpyPresent) options += (options ? " + " : String()) + "Anti-ILSpy";




    const sbieVariants = [
        "sbiedll.",
        "SbieDll.",
        "SBIEDLL."
    ];

    var isAntiSbiePresent = false;

    // Check if the signature for 'GetModuleHandle' is present
    if (validateSignature("'GetModuleHandle'")) { // from 'kernel32.dll'
        // Iterate through Sandboxie variants
        for (var l in sbieVariants) {
            if (!isAntiSbiePresent) {
                const sbieLib = sbieVariants[l];

                // Check if the signature for Sandboxie variant is valid using Unicode signature mask or the original signature
                if (
                    validateGlobalUnicodeString(sbieLib) ||
                    validateSignature("'" + sbieLib + "'")
                ) {
                    // Set flag indicating the presence of anti-Sandboxie behavior
                    isAntiSbiePresent = true;
                }
            }
        }
    }

    if (isAntiSbiePresent) options += (options ? " + " : String()) + "Anti-SandBoxie";




    var isAntiVmPresent = false;

    if (validateNetUnicodeString("vmware") || validateNetUnicodeString("VirtualBox")) {
        isAntiVmPresent = true;
    }

    if (isAntiVmPresent) options += (options ? " + " : String()) + "Anti-VM";




    if (options.length != 0) isDetected = true;


    if (isDetected) {
        _setResult("~protection", "Anti analysis", String(), PE.isVerbose() ? options : String());
    }
}




/**
 * Determines if the current PE file is a C++/CLR .NET application.
 *
 * Checks if the PE file:
 * - Is a .NET assembly
 * - Imports the "KERNEL32.DLL" library
 * - Has a .NET global class constructor present
 *
 * @returns {boolean} True if the PE file matches the C++/CLR .NET application heuristics, otherwise false.
 */
function isCppClrLikeApp() {
    return PE.isNet() && PE.isLibraryPresent("KERNEL32.DLL") && PE.isNetGlobalCctorPresent();
}



/**
 * Microsoft Intermediate Language (MSIL) OpCodes class for .NET assembly analysis.
 * 
 * This class provides a comprehensive collection of MSIL instruction opcodes with their
 * corresponding bytecode patterns for signature-based detection in .NET assemblies.
 * All opcode values are verified against the official Microsoft .NET Runtime source code
 * and ECMA-335 Common Language Infrastructure (CLI) specification.
 * 
 * @class NetOpCodes
 * @description Represents MSIL opcodes as hexadecimal string patterns for bytecode matching.
 * 
 * Features:
 * - Complete MSIL instruction set coverage (93 opcodes)
 * - Support for both single-byte (0x00-0xFF) and two-byte (0xFE00-0xFEFF) opcodes
 * - Wildcard pattern support using '?' for variable operands
 * - Prefix instruction handling (volatile, tail, readonly, etc.)
 * - Helper methods for strict value substitution and null value setting
 * 
 * Pattern Format:
 * - Fixed bytes: "58" (add instruction)
 * - Variable operands: "28????????" (call with 4-byte method token)
 * - Short operands: "2B??" (br.s with 1-byte offset)
 * - Two-byte opcodes: "FE01" (ceq instruction)
 * 
 * Helper Methods:
 * - setStrict(opcode, value): Sets specific operand values for opcodes
 * - setNullValue(opcode): Replaces wildcards with zero bytes
 * 
 * @see {@link https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes} Microsoft OpCodes Documentation
 * @see {@link https://www.ecma-international.org/publications-and-standards/standards/ecma-335/} ECMA-335 CLI Specification
 * @see {@link https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Reflection/Emit/OpCodes.cs} .NET Runtime Source
 */
function NetOpCodes() {
    // ========== BASIC STACK OPERATIONS ==========
    this.dup = "25"; // MSIL: 'dup' - Duplicate top stack value
    this.nop = "00"; // MSIL: 'nop' - No operation
    this.pop = "26"; // MSIL: 'pop' - Remove top stack value

    // ========== ARITHMETIC OPERATIONS ==========
    this.add = "58"; // MSIL: 'add' - Add two values
    this.div = "5B"; // MSIL: 'div' - Divide two values
    this.mul = "5A"; // MSIL: 'mul' - Multiply two values
    this.neg = "65"; // MSIL: 'neg' - Negate value
    this.rem_un = "5E"; // MSIL: 'rem.un' - Remainder (unsigned)
    this.sub = "59"; // MSIL: 'sub' - Subtract two values

    // ========== LOGICAL OPERATIONS ==========
    this.and = "5F"; // MSIL: 'and' - Bitwise AND
    this.not = "66"; // MSIL: 'not' - Bitwise NOT
    this.or = "60"; // MSIL: 'or' - Bitwise OR
    this.shl = "62"; // MSIL: 'shl' - Shift left
    this.shr = "63"; // MSIL: 'shr' - Shift right
    this.shr_un = "64"; // MSIL: 'shr.un' - Shift right (unsigned)
    this.xor = "61"; // MSIL: 'xor' - Bitwise XOR

    // ========== COMPARISON OPERATIONS ==========
    this.ceq = "FE01"; // MSIL: 'ceq' - Compare equal

    // ========== CONSTANT LOADING ==========
    this.ldc_i4 = "20????????"; // MSIL: 'ldc.i4' - Load 32-bit integer constant
    this.ldc_i4_0 = "16"; // MSIL: 'ldc.i4.0' - Load constant 0
    this.ldc_i4_1 = "17"; // MSIL: 'ldc.i4.1' - Load constant 1
    this.ldc_i4_2 = "18"; // MSIL: 'ldc.i4.2' - Load constant 2
    this.ldc_i4_3 = "19"; // MSIL: 'ldc.i4.3' - Load constant 3
    this.ldc_i4_4 = "1A"; // MSIL: 'ldc.i4.4' - Load constant 4
    this.ldc_i4_s = "1F??"; // MSIL: 'ldc.i4.s' - Load small integer constant

    // ========== ARGUMENT OPERATIONS ==========
    this.ldarg_0 = "02"; // MSIL: 'ldarg.0' - Load argument 0
    this.ldarg_1 = "03"; // MSIL: 'ldarg.1' - Load argument 1
    this.ldarg_2 = "04"; // MSIL: 'ldarg.2' - Load argument 2
    this.ldarg_3 = "05"; // MSIL: 'ldarg.3' - Load argument 3
    this.ldarg_s = "0E??"; // MSIL: 'ldarg.s' - Load argument (short form)
    this.starg_s = "10??"; // MSIL: 'starg.s' - Store to argument (short form)

    // ========== LOCAL VARIABLE OPERATIONS ==========
    this.ldloc = "FE0C????"; // MSIL: 'ldloc' - Load local variable
    this.ldloc_0 = "06"; // MSIL: 'ldloc.0' - Load local variable 0
    this.ldloc_1 = "07"; // MSIL: 'ldloc.1' - Load local variable 1
    this.ldloc_2 = "08"; // MSIL: 'ldloc.2' - Load local variable 2
    this.ldloc_3 = "09"; // MSIL: 'ldloc.3' - Load local variable 3
    this.ldloc_s = "11??"; // MSIL: 'ldloc.s' - Load local variable (short form)
    this.stloc = "FE0E????"; // MSIL: 'stloc' - Store to local variable
    this.stloc_0 = "0A"; // MSIL: 'stloc.0' - Store to local variable 0
    this.stloc_1 = "0B"; // MSIL: 'stloc.1' - Store to local variable 1
    this.stloc_2 = "0C"; // MSIL: 'stloc.2' - Store to local variable 2
    this.stloc_3 = "0D"; // MSIL: 'stloc.3' - Store to local variable 3
    this.stloc_s = "13??"; // MSIL: 'stloc.s' - Store to local variable (short form)

    // ========== FIELD OPERATIONS ==========
    this.ldfld = "7B????????"; // MSIL: 'ldfld' - Load instance field
    this.ldflda = "7C????????"; // MSIL: 'ldflda' - Load field address
    this.ldsfld = "7E????????"; // MSIL: 'ldsfld' - Load static field
    this.stfld = "7D????????"; // MSIL: 'stfld' - Store to instance field

    // ========== ARRAY OPERATIONS ==========
    this.ldelem_i = "97"; // MSIL: 'ldelem.i' - Load array element (native int)
    this.ldelem_u4 = "95"; // MSIL: 'ldelem.u4' - Load array element (unsigned 32-bit)
    this.ldelema = "8F????????"; // MSIL: 'ldelema' - Load array element address
    this.ldlen = "8E"; // MSIL: 'ldlen' - Load array length
    this.newarr = "8D????????"; // MSIL: 'newarr' - Create new array
    this.stelem_i = "9B"; // MSIL: 'stelem.i' - Store to array element (native int)
    this.stelem_i1 = "9C"; // MSIL: 'stelem.i1' - Store to array element (8-bit)
    this.stelem_i4 = "9E"; // MSIL: 'stelem.i4' - Store to array element (32-bit)

    // ========== INDIRECT OPERATIONS ==========
    this.ldind_i4 = "4A"; // MSIL: 'ldind.i4' - Load indirect 32-bit value
    this.stind_i4 = "54"; // MSIL: 'stind.i4' - Store indirect 32-bit value

    // ========== CONTROL FLOW ==========
    this.beq = "3B????????"; // MSIL: 'beq' - Branch if equal
    this.bge = "3C????????"; // MSIL: 'bge' - Branch if greater or equal
    this.bgt = "3D????????"; // MSIL: 'bgt' - Branch if greater than
    this.ble = "3E????????"; // MSIL: 'ble' - Branch if less or equal
    this.blt = "3F????????"; // MSIL: 'blt' - Branch if less than
    this.bne_un = "40????????"; // MSIL: 'bne.un' - Branch if not equal (unsigned)
    this.bne_un_s = "33??"; // MSIL: 'bne.un.s' - Branch if not equal (unsigned, short)
    this.br = "38????????"; // MSIL: 'br' - Unconditional branch
    this.br_s = "2B??"; // MSIL: 'br.s' - Unconditional branch (short form)
    this.brfalse = "39????????"; // MSIL: 'brfalse' - Branch if false/null/zero
    this.brfalse_s = "2C??"; // MSIL: 'brfalse.s' - Branch if false/null/zero (short)
    this.brtrue = "3A????????"; // MSIL: 'brtrue' - Branch if true/non-null/non-zero
    this.brtrue_s = "2D??"; // MSIL: 'brtrue.s' - Branch if true/non-null/non-zero (short)
    this.call = "28????????"; // MSIL: 'call' - Call method
    this.calli = "29????????"; // MSIL: 'calli' - Call indirect
    this.ldtoken = "D0????????"; // MSIL: 'ldtoken' - Load metadata token
    this.ldftn = "FE06????????"; // MSIL: 'ldftn' - Load function pointer
    this.ret = "2A"; // MSIL: 'ret' - Return from method
    this.switch__nobody = "45"; // MSIL: 'switch' - Switch statement

    // ========== TYPE OPERATIONS ==========
    this.box = "8C????????"; // MSIL: 'box' - Convert value type to object reference
    this.castclass = "74????????"; // MSIL: 'castclass' - Cast object to class
    this.conv_i4 = "69"; // MSIL: 'conv.i4' - Convert to 32-bit integer
    this.conv_u4 = "6D"; // MSIL: 'conv.u4' - Convert to unsigned 32-bit integer
    this.isinst = "75????????"; // MSIL: 'isinst' - Test if object is instance of class
    this.sizeof = "FE1C????????"; // MSIL: 'sizeof' - Get size of value type
    this.unbox = "79????????"; // MSIL: 'unbox' - Convert object reference to value type
    this.unbox_any = "A5????????"; // MSIL: 'unbox.any' - Convert boxed type to value

    // ========== OBJECT OPERATIONS ==========
    this.cpobj = "70????????"; // MSIL: 'cpobj' - Copy value type
    this.initobj = "FE15????????"; // MSIL: 'initobj' - Initialize value type
    this.ldobj = "71????????"; // MSIL: 'ldobj' - Load value type from address
    this.ldstr = "72????????"; // MSIL: 'ldstr' - Load string literal
    this.newobj = "73????????"; // MSIL: 'newobj' - Create new object instance
    this.stobj = "81????????"; // MSIL: 'stobj' - Store value type to address

    // ========== EXCEPTION HANDLING ==========
    this.rethrow = "FE1A"; // MSIL: 'rethrow' - Rethrow current exception
    this._throw = "7A"; // MSIL: 'throw' - Throw exception

    // ========== PREFIX INSTRUCTIONS ==========
    this.readonly = "FE1E"; // MSIL: 'readonly' - Subsequent array address operation performs no type check
    this.tail = "FE14"; // MSIL: 'tail' - Subsequent call terminates current method
    this.volatile = "FE13"; // MSIL: 'volatile' - Subsequent pointer reference is volatile

    // ========== UTILITY OPCODES ==========
    this._unknown = "**"; // Unknown opcode pattern
    this._any = "??"; // Any single opcode pattern

    /**
     * Sets strict operand values for MSIL opcodes with variable operands.
     * 
     * This method replaces wildcard patterns ('??') in opcode masks with specific 
     * hexadecimal values, allowing for precise bytecode pattern matching.
     * 
     * @method setStrict
     * @param {string} opCodeMask - The opcode pattern with wildcards (e.g., "20????????")
     * @param {string} value - The hexadecimal value to substitute (e.g., "01 00 00 00")
     * @returns {string} The opcode pattern with substituted values
     * 
     * @example
     * // Set ldc.i4 instruction to load constant value 1
     * var pattern = opCodes.setStrict(opCodes.ldc_i4, "01 00 00 00");
     * // Result: "2001000000" (ldc.i4 1)
     * 
     * @example
     * // Set specific method token for call instruction
     * var callPattern = opCodes.setStrict(opCodes.call, "10 00 00 06");
     * // Result: "2810000006" (call method token 0x06000010)
     * 
     * @throws {Error} If operand size doesn't match the expected size
     */
    this.setStrict = function (opCodeMask, value) {
        // Remove spaces from opcode mask and value
        opCodeMask = removeWhitespaces(opCodeMask);
        value = removeWhitespaces(value);

        // Find the index of the special pattern "??" in the opcode mask
        var indexOfSpecialPattern = opCodeMask.indexOf("??");

        // Check if the opcode mask has a body (contains the special pattern "??")
        var isOpCodeMaskHasBody = indexOfSpecialPattern !== -1; // -1 if not found

        // Extract the opcode in hexadecimal
        var opCodeInHex = isOpCodeMaskHasBody ? opCodeMask.substring(0x00, indexOfSpecialPattern) : opCodeMask;

        // Check if the opcode mask has a body and the length of the body matches the length of the value
        if (isOpCodeMaskHasBody && opCodeMask.substring(opCodeInHex.length).length != value.length) {
            _error("The size of the input values does not match.");
        }

        // Combine the opcode in hexadecimal with the value
        return opCodeInHex + value;
    }

    /**
     * Sets all wildcard operands in an opcode pattern to zero bytes.
     * 
     * This method replaces all wildcard patterns ('??') in the opcode mask with 
     * zero bytes ('00'), useful for matching instructions with null/empty operands.
     * 
     * @method setNullValue
     * @param {string} opCodeMask - The opcode pattern containing wildcards
     * @returns {string} The opcode pattern with all wildcards replaced by '00'
     * 
     * @example
     * // Set ldc.i4 instruction to load zero value
     * var pattern = opCodes.setNullValue(opCodes.ldc_i4);
     * // Result: "2000000000" (ldc.i4 0)
     * 
     * @example
     * // Create null branch instruction
     * var brPattern = opCodes.setNullValue(opCodes.br);
     * // Result: "3800000000" (br with zero offset)
     * 
     * @throws {Error} If the opcode mask contains no wildcards to replace
     */
    this.setNullValue = function (opCodeMask) {

        if (opCodeMask.indexOf("??") === -1) {
            _error("Instruction does not have a body to overwrite the value.");
        }

        return replaceAllInString(opCodeMask, "??", "00");
    }

    /**
     * Joins an opcode without wildcards with additional bytes.
     * 
     * This method concatenates opcodes that don't have wildcards (like switch) 
     * with specific byte sequences, useful for instructions with variable-length operands.
     * 
     * @method joinNoBodyAndValue
     * @param {string} opCode - The opcode without wildcards (e.g., "45" for switch)
     * @param {string} value - The hexadecimal bytes to append (e.g., "02 00 00 00 XX XX XX XX")
     * @param {string} [opCodeName] - Optional: name of the opcode variable for validation
     * @returns {string} The combined opcode pattern
     * 
     * @example
     * // Create switch instruction with 2 targets
     * var switchPattern = opCodes.joinNoBodyAndValue(opCodes.switch__nobody, "02 00 00 00 10 00 00 00 20 00 00 00", "switch__nobody");
     * // Result: "45020000001000000020000000" (switch with 2 targets at offsets 0x10 and 0x20)
     * 
     * @throws {Error} If the opcode contains wildcards (should use setStrict instead)
     * @throws {Error} If opCodeName is provided but doesn't contain '__nobody'
     */
    this.joinNoBodyAndValue = function (opCode, value, opCodeName) {
        // Type validation
        if (!opCode || typeof opCode !== "string") {
            _error("Invalid opcode provided.");
        }
        if (!value || typeof value !== "string") {
            _error("Invalid value provided.");
        }

        // Check that opcode doesn't contain wildcards
        if (opCode.indexOf("??") !== -1) {
            _error("Opcode contains wildcards. Use setStrict() instead.");
        }

        // Optional validation: check if opcode name contains '__nobody'
        if (opCodeName && typeof opCodeName === "string") {
            if (opCodeName.indexOf("__nobody") === -1) {
                _error("joinNoBodyAndValue should only be used with '__nobody' opcodes (variable-length instructions).");
            }
        }

        return opCode + removeWhitespaces(value);
    }
}



/**
 * Removes all whitespace characters from a string including spaces, tabs, newlines, and carriage returns.
 * 
 * @param {string} inputString - The input string to remove whitespaces from
 * @returns {string} The string with all whitespace characters removed, or an empty string if input is invalid
 */
function removeWhitespaces(inputString) {
    // Type validation to prevent runtime errors
    if (!inputString || typeof inputString !== "string") {
        return String();
    }

    // Regex removes all whitespace: spaces, tabs, newlines, carriage returns
    return inputString.replace(/\s+/g, "");
}




/**
 * Replaces all occurrences of a specified substring within a given string with a new substring.
 * Uses split/join algorithm for single-pass replacement.
 *
 * @param {string} inputString - The original string in which to perform the replacements.
 * @param {string} search - The substring to search for within the input string.
 * @param {string} replacement - The substring to replace each occurrence of the search substring with.
 * @returns {string} - The modified string with all occurrences of the search substring replaced by the replacement substring.
 */
function replaceAllInString(inputString, search, replacement) {
    // Type validation to prevent runtime errors
    if (!inputString || typeof inputString !== "string") {
        return String();
    }

    if (!search || typeof search !== "string") {
        return inputString;
    }

    if (typeof replacement !== "string") {
        replacement = String();
    }

    // Split on search string and join with replacement (single pass)
    return inputString.split(search).join(replacement);
}



/**
 * Sanitizes section names to prevent DiE output corruption from malformed PE files.
 * Removes control characters that could break console output or cause display issues.
 * 
 * @param {string} sectionName - The section name to clean and sanitize.
 * @returns {string} - The sanitized section name safe for DiE output.
 */
function clearSectionName(sectionName) {
    // Type validation to prevent runtime errors
    if (!sectionName || typeof sectionName !== "string") {
        return String();
    }

    // Remove control characters (0x00-0x1F) and extended control chars (0x7F-0x9F)
    // This prevents newlines, tabs, null bytes from breaking DiE output format
    var cleaned = sectionName.replace(/[\x00-\x1F\x7F-\x9F]/g, "");

    // Remove leading/trailing whitespace
    cleaned = cleaned.trim();

    return cleaned;
}



/**
 * Checks if a given string consists only of ANSI printable characters (ASCII range 0x20 to 0x7E).
 *
 * @param {string} inputString - The string to validate.
 * @returns {boolean} Returns true if the string contains only ANSI printable characters, otherwise false.
 */
function isAnsiString(inputString) {
    // Type validation to prevent runtime errors
    if (!inputString || typeof inputString !== "string") {
        return String();
    }

    return /^[\x20-\x7E]+$/.test(inputString);
}



/**
 * Returns the file name without its extension.
 *
 * @param {string} fileName - The name of the file, possibly including an extension.
 * @returns {string} The file name without the extension. If no extension is found, returns the original file name.
 */
function getFileNameWithoutExtension(fileName) {
    // Type validation to prevent runtime errors
    if (!fileName || typeof fileName !== "string") {
        return String();
    }

    // Remove the file extension by splitting on the last dot and returning the first part
    var lastDotIndex = fileName.lastIndexOf(".");
    if (lastDotIndex === -1) {
        return fileName; // No extension found, return original name
    }

    return fileName.substring(0, lastDotIndex);
}



// This feature was originally intended only for .NET, but
// now partially works with Native files.

function scanForPackersAndCryptors_NET_and_Native() { // For .NET and Native apps
    var options = String();

    var isDetected = Boolean(),
        isCryptor = Boolean();




    if (PE.isNet()) {

        var isAssemblyInvokeFound = false;

        if (!isFrameworkComponent() && PE.getNetModuleName !== "System.dll" && isAllNetReferencesPresent( // TODO: update [!!!]
            references = [
                "System.Reflection", // System.Reflection.dll
                "get_EntryPoint", // MSIL: '*.Assembly::get_EntryPoint()'
                "Assembly", // MSIL: 'System.Reflection.Assembly' from System.Reflection.dll
                "Invoke", // MSIL: '*.MethodBase::Invoke(object, object[])'
                "Load" // MSIL: '*.Assembly::Load(uint8[])'
            ]
        )) {
            isAssemblyInvokeFound = true;

            options = "Assembly invoke";
        }




        // Check if any class from System.Security.Cryptography namespace is used (non-full name) - for cryptors
        if (findAndMark("System.Security.Cryptography", isFullName = false) != String()) {

            // Specify cryptography classes to look for
            const cryptoClasses = [
                "TripleDESCryptoServiceProvider",
                "RSACryptoServiceProvider",
                "DSACryptoServiceProvider",
                "DESCryptoServiceProvider",
                "AesCryptoServiceProvider",
                "Rfc2898DeriveBytes",
                "TripleDES",
                "Rijndael",
                "ECDsaCng",
                "AesAEAD",
                "Aes192Cbc",
                "Aes256Cbc",
                "Aes128Cbc",
                "AesManaged",
                "AesCng",
                "RC2CryptoServiceProvider",
                "RNGCryptoServiceProvider"
            ];

            // Iterate through cryptography classes
            for (var i in cryptoClasses) {
                if (!isCryptor) {
                    var cryptoClassSign = cryptoClasses[i],
                        result = findAndMark(
                            sign = cryptoClassSign,
                            isFullName = true
                        );

                    // Check if assembly invoke is found and the cryptography class is present
                    if (isAssemblyInvokeFound && result.length) {
                        log(logType.net, "Crypto class present: " + cryptoClassSign);

                        isCryptor = true;

                        // Add the cryptography class to options
                        options += (options ? " + " : String()) + cryptoClassSign;
                    }
                }
            }
        }




        // Check if any class from System.IO.Compression namespace is used (non-full name)
        if (findAndMark("System.IO.Compression", isFullName = false).length) {

            // Specify compression classes to look for
            const compressionClasses = [
                "DeflateStream",
                "GZipStream"
            ];

            // Iterate through compression classes
            for (var i in compressionClasses) {
                var compressionClassSign = compressionClasses[i],
                    result = findAndMark(compressionClassSign, isFullName = true);

                // Check if assembly invoke is found and the compression class is present
                if (isAssemblyInvokeFound && result.length) {
                    log(logType.net, "Compression class present: " + compressionClassSign);

                    // If it's a cryptor, add the compression class to options
                    if (isCryptor) options += (options ? " + " : String()) + compressionClassSign;

                    // Break the loop if a match is found
                    break;
                }
            }
        }




        var isRunPePresent = false;

        if (PE.isNetObjectPresent("RunPE") ||
            PE.isNetObjectPresent("PELoader") || // https://github.com/nettitude/RunPE/blob/main/RunPE/Internals/PELoader.cs
            PE.isNetObjectPresent("CMemoryExecute") || // https://github.com/wojciech-kulik/Sample-Projects/blob/master/Windows%20Desktop/WIN32_MemoryAppLoader/MemoryAppLoader/CMemoryExecute.cs
            (PE.isNetObjectPresent("GetProcAddress") && PE.isNetUStringPresent("WriteProcessMemory") && PE.isNetUStringPresent("VirtualAllocEx") && PE.isNetUStringPresent("ZwUnmapViewOfSection")) ||
            (
                (PE.isNetObjectPresent("WriteProcessMemory") || PE.isNetObjectPresent("NtWriteVirtualMemory")) &&
                (PE.isNetObjectPresent("ZwUnmapViewOfSection") || PE.isNetObjectPresent("NtUnmapViewOfSection")) &&
                (PE.isNetObjectPresent("CreateProcess") || PE.isNetObjectPresent("NtCreateProcess") || PE.isNetObjectPresent("CreateProcessA") || PE.isNetObjectPresent("CreateProcessW")) &&
                PE.isNetObjectPresent("VirtualAllocEx"))
        ) {
            isRunPePresent = true;
        }

        if (isRunPePresent) options += (options ? " + " : String()) + "RunPE";
    }




    // Self-Extracting archives
    // TODO: Upgrade

    var isSfx = false;

    if (!PE.isDll() && PE.isOverlayPresent()) {
        const overlayPatterns = [
            "'Rar!'", // samples by: WinRAR
            "'PK'03", // samples by: Zip SFX (by Intel)
            "';!@Install@!UTF-8!'", "'7z'BCAF271C", "efbbbf';!@Install@!UTF-8!'" // samples by: 7z
        ]

        for (var l in overlayPatterns) {
            if (PE.compareOverlay(overlayPatterns[l])) {
                log(logType.nothing, "SFX overlay pattern: " + overlayPatterns[l]);
                isSfx = true;
            }
        }


        if (!isSfx && !PE.isNet()) {
            const sfxEntries = [
                // "E8$$$$$$$$558BEC83EC..A1........8365....8365....5357BF........3BC7BB........74..85C374..F7D0", // samples by: WinZip
                // "558BEC6A..68........68........64A1........50648925........83....5356578965..FF15", // samples by: Zip SFX
                // "E8$$$$$$$$558BEC83EC..8365....8365....A1........5657BF........BE........3BC7", // samples by: WinRAR Installer
                // "E8$$$$$$$$8BFF558BEC83EC..A1........8365....8365....5357BF........BB", // samples by: Zip SFX
                // "558BEC83C4..B8........E8........33C05568........64FF30648920E8", // samples by: Zip SFX
                // "4883EC..E8$$$$$$$$48895C24..55488BEC4883EC..488365....48BB................488B05........483BC375", // samples by: WinRAR Installer
                "83EC..5657FF15........8BF08D4424..50C74424..........FF15........8A068B3D........3C..75..56FFD7", // samples by: Zip SFX
                "E9$$$$$$$$558BEC81EC........830D..........5356576A..33DBBF........68........895D..881D", // samples by: Microsoft Cabinet
                "558BEC83EC..56FF15........8BF08A003C..75..84C074..803E..74..46803E..75..803E..75..46EB", // samples by: Zip SFX
                "6A..33C0505050FF15........50E8$$$$$$$$55B8........8BECE8........53B9........5657BE", // samples by: Zip SFX
                "6A..68........E8........66813D............75..A1........81B8................75..", // samples by: Microsoft Cabinet
                "558BEC83EC..565733FFFF15........8BF0897D..8D45..50FF15........8A063C..75..56FF15", // samples by: Zip SFX
                "51526A..2EFF15........506A..6A..2EFF15........50E8........502EFF15........5A59C3", // samples by: WinIMP
                "558BEC81EC........535657FF15........A3........FF15........A1........6625....3D", // samples by: Microsoft Cabinet
                "558BECB8........E8........5356BE........578D45..5633DB5053FF15........85C00F84", // samples by: Zip SFX
                "A1........C1E0..A3........575133C0BF........B9........3BCF76..2BCFFCF3AA595F", // samples by: WinRAR Installer
                "558BEC83C4..5356E8$$$$$$$$E8........6A..E8........8905........E8........8905", // samples by: Zip SFX
                "FF15........B1..380874..B1..4080....74..380874..4080....75..80....74..4033", // samples by: WinZip
                "53FF15........B3..38..74..80C3..4033D28A083ACA74..3ACB74..408A083ACA75", // samples by: WinZip
                "558BEC83C4..535657E8........E8........33C05568........64FF30648920E8", // samples by: WinRAR
                "53FF15........B3..38..74..80C3..8A48..4033D23ACA74..3ACB74..8A48..40", // samples by: WinZip
                "E8$$$$$$$$53BB........E8........85C074..33D28A1083FA..75..40EB", // samples by: WinRAR
                "FFFE2A002A002A006D0065007300730061006700650073002A002A002A00", // samples by: WinRAR Installer
                "E8$$$$$$$$558BEC83C4..B8........53", // samples by: WinRAR Installer
                "8A48014033D23ACA740A3ACB74068A4801" // samples by: WinZip
            ]

            if (PE.isSectionNamePresent("_winzip_")) {
                isSfx = true;
            }

            for (var k in sfxEntries) {
                if (PE.compareEP(sfxEntries[k])) {
                    log(logType.nothing, "SFX entry pattern: " + sfxEntries[k]);

                    isSfx = true;
                }
            }
        }
    }

    if (isSfx) options += (options ? " + " : String()) + "SFX";




    var entryLikePacker = false;

    const entries = [
        "53565755488D35........488DBE", // samples by: UPX (x64)
        "B8........68........64", // samples by: Petite (x32)
        "60..................E8", // samples by: Anticrack Software (x32)
        "33C08BC068........68", // samples by: ExE Pack (x32)
        "74..E9........60E8", // samples by: PE-PACK
        "EB0668........C39C", // samples by: PECompact (x32)
        "93071F05....8ED0BC", // samples by: aPack (x32)
        "60BE........8DBE", // samples by: UPX (x32)
        "B8........6A..68", // samples by: Petite (x32)
        "BE........AD8BF8", // samples by: WinUPack (x32)
        "68........9C60E8", // samples by: XComp, XPACK (x32)
        "53558BE833DBEB60", // samples by: WWPack (x32)
        "BD........C745", // samples by: kkrunchy (x32)
        "57565351524150", // samples by: mpress (x64)
        "B8........5064", // samples by: PECompact (x32)
        "8CCBBA....03DA", // // samples by: aPack (x32)
        "B8........669C", // samples by: Petite, Themida (x32)
        "8CC0FA8ED0BC", // samples by: PACKWIN (x32)
        "B8........60", // samples by: Petite, Themida (x32)
        "8B44240456", // samples by: ASDPack (x32)
        "1E068CC88E", // samples by: aPack (x32)
        "1E068CCBBA", // samples by: aPack (x32)
        "EB..9C60E8", // samples by: PECompact (x32)
        "9C60E8CA", // samples by: Petite (x??)
        "60FCBED4", // samples by: ANDPakk (x32)
        "60EB..5D", // samples by: ASPack (x32)
        "60EB..E8", // samples by: G!X Protector
        "64FF35", // samples by: Petite (x32)
        "6033C0", // samples by: yzPack (x32)
        "669C60", // samples by: Petite (x??)
        "EB..60", // samples by: kkryptor, dePACK (x32)
        "60E8", // samples by: mpress, Packman, Pack Master, Yodas Crypter, DxPack, ASPack, MSLRH, tElock (x32), WinUPack
        "6068" // samples by: BeRo, ExE Pack, AHPacker (x32)
    ];

    // Iterate through the entries to check against the entry point
    for (var e in entries) {
        if (!entryLikePacker) {
            const entryToCheck = entries[e];

            // If the entry point matches the current entry, set the flag to true and break the loop
            if (PE.compareEP(entryToCheck)) {
                log(logType.nothing, "EP like a packer: \"" + entryToCheck + "\"");

                entryLikePacker = true;
            }
        }
    }

    if (entryLikePacker) options += (options ? " + " : String()) + "EntryPoint";




    // Check if the first instruction at entry point starts with a stack operation

    var isStartsWithStackOperation = false;

    // Get the opcode of the first instruction at entry point
    const firstEpAsmOpCode = getFirstEpAsmOpCode();

    // Switch statement to check for specific stack operation opcodes
    switch (firstEpAsmOpCode) {
        case "PUSHAL":
        case "PUSHA":
        case "PUSHF":
        case "POPA":
            log(logType.nothing, "'" + firstEpAsmOpCode + "' at EP");

            isStartsWithStackOperation = true;
    }

    if (isStartsWithStackOperation) options += (options ? " + " : String()) + firstEpAsmOpCode[0].toUpperCase() + firstEpAsmOpCode.toLowerCase().substring(1, firstEpAsmOpCode.length) + " at EP";




    // Check if the entry point is in the last section

    var isLastSectionEP = false;

    if (!PE.isDll()) {
        if (PE.getNumberOfSections() > 1) {
            // Get addresses of the last section and entry point

            var lastSectionAddress = -1,
                entryPointAddress = -1;


            // Get last section with non -1 address
            for (var i = 1; lastSectionAddress == -1; i++) {
                lastSectionAddress = PE.OffsetToVA(PE.getSectionFileOffset(PE.getNumberOfSections() - i));
            }

            entryPointAddress = PE.getAddressOfEntryPoint();


            // Check if the entry point is greater than or equal to the last section address
            if (entryPointAddress >= lastSectionAddress) {
                log(logType.nothing, "EP address (" + entryPointAddress + ") more than last section address (" + lastSectionAddress + ")");

                isLastSectionEP = true;
            }
        }
    }

    if (isLastSectionEP) options += (options ? " + " : String()) + "Last section EP";




    // Check for strange calls if entry point is in the last section

    var isStrangeCallOrJmpPresent = false;

    var firstOpCode = getAsmOpCode(getAsmInstructionByIndex(0));

    if (!PE.isDll()) {
        if (isLastSectionEP && !PE.compareEP("E8 00 00 00 00") && (firstOpCode === "CALL" || firstOpCode === "JMP")) {
            log(logType.nothing, "Strange " + firstOpCode.toLowerCase() + " at EP to address: " + getAsmInstructionByIndex(0).split(" ")[1].toLowerCase());
            isStrangeCallOrJmpPresent = true;
        }
    }

    if (isStrangeCallOrJmpPresent) options += (options ? " + " : String()) + "Strange " + firstOpCode.toLowerCase() + " at EP";




    // Check for packers and protections by imports (hashes)

    var isImportsLikePacker = false;

    // ["Name", "Version", ImportLibraryIndex, Hash, Type (0 = packer, 1 = protector, 2 = protection)]
    // If {ImportLibraryIndex} is -1, it means the hash has no index

    var dbCollectionOfHashesDictionary = [
        // packers
        ["UPX", "0.59-0.93", 0, 0xd4fdcab1, 0], // https://github.com/upx/upx
        ["UPX", "0.94-1.93", 0, 0x1d51299a, 0],
        ["UPX", "1.94-2.03", 0, 0xb3318086, 0],
        ["UPX", "1.94-2.03", 0, 0x3778aab9, 0],
        ["UPX", "2.90-3.XX", 0, 0xf375ee03, 0],
        ["UPX", "2.90-3.XX", 0, 0xf737d853, 0],
        ["UPX", "3.91+", 0, 0xf737d853, 0],
        ["UPX", "3.91+", -1, 0x82a048fc, 0],
        ["UPX", "3.91+", -1, 0x554a1748, 0],
        ["NsPack", null, 0, 0xf375ee03, 0], // https://nspack.apponic.com/
        ["NsPack", "3.X", 0, 0x86111e49, 0], // For .NET
        ["ASPack", "1.XX-2.XX", 0, 0x1272f45b, 0], // https://www.aspack.com/
        ["ASPack", null, 0, 0xee6ea174, 0],
        ["MKFPACK", null, 0, 0x42b3e7f9, 0],
        ["MPRESS", null, 0, 0x174efb84, 0], // https://www.autohotkey.com/mpress/mpress_web.htm
        ["Packman", "0.0.0.1", 0, 0x174efb84, 0],
        ["Packman", "1.0", 0, 0x69076a83, 0],
        ["PECompact", "0.90-0.91", -1, 0xbea416d1, 0], // https://bitsum.com/portfolio/pecompact/
        ["PECompact", "0.92-0.94", -1, 0x93312c2e, 0],
        ["PECompact", "0.97-0.971b", -1, 0xe6aa8495, 0],
        ["PECompact", "0.975-1.10b3", -1, 0x29188619, 0],
        ["PECompact", "1.10b7-1.34", -1, 0xe4c11305, 0],
        ["PECompact", "1.30-1.40", 0, 0x9b3305ed, 0],
        ["PECompact", "1.40-1.84", 0, 0xcc5b2a3c, 0],
        ["PECompact", "2.40-3.XX", 0, 0x2652ce4f, 0],
        ["PECompact", "2.40-3.XX", -1, 0xdb8fbb75, 0],
        ["EXE32PACK", "1.3X-1.4X", 0, 0x174efb84, 0],
        ["tElock", "1.0", -1, 0x051946f7, 0], // https://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/Telock.shtml
        ["JDPACK", "2.00", 0, 0xc002db0e, 0],
        ["CRINKLER", null, 0, 0x0b0e1fbf, 0],
        ["WinUpack", null, -1, 0x29188619, 0],
        ["YodasCrypter", "1.X", -1, 0x1303a51b, 0],
        ["XComp", "0.97-0.98", -1, 0xea1e66e4, 0],
        ["XPack", "0.97-0.98", -1, 0x2ac44dd2, 0],
        ["kkrunchy", null, -1, 0x29188619, 0], // https://www.farbrausch.de/~fg/kkrunchy/
        ["ANDPakk2", "0.18", -1, 0x29188619, 0],
        ["EXECryptor", "1.4-1.5", -1, 0xd1de53b5, 0],
        ["EXECryptor", "2.X", -1, 0xf51b2817, 0],
        ["RLPack", "1.1-1.2", 0, 0x5bd1d713, 0],
        ["Petite", "2.2", -1, 0x61e53682, 0],
        ["bambam", "0.1-0.4", 0, 0xb5b153cd, 0],
        ["py2exe", null, 2, 0xe5907ffa, 0],
        // protectors
        ["ASProtect", "1.XX-2.XX", 0, 0x1272f45b, 1],
        ["SHRINKER", "3.2", 0, 0xb2a64858, 1],
        ["SHRINKER", "3.2", 0, 0x158af2d0, 1],
        ["SHRINKER", "3.2", 0, 0x49e8aa1f, 1],
        ["SHRINKER", "3.5", 0, 0xe9ea0851, 1],
        ["SHRINKER", "3.5", 0, 0x3344b95d, 1],
        ["SHRINKER", "3.5", 0, 0x586088f3, 1],
        ["Enigma", "1.00-3.60", 0, 0xc002db0e, 1], // https://enigmaprotector.com/
        ["Enigma", "2.XX", 0, 0xdd92de10, 1],
        ["Enigma", "3.70+", 0, 0xd04c7a50, 1],
        ["PCGUARD", "5.04-5.05", 0, 0x5a169c7a, 1],
        ["PCGUARD", "5.04-5.05", 0, 0x0b0b2965, 1],
        ["eXPressor", "1.2", -1, 0x66b35c6e, 1], // https://www.cgsoftlabs.ro/express.html
        ["eXPressor", "1.2", -1, 0x32f4466c, 1],
        ["eXPressor", "1.3", -1, 0x921d0280, 1],
        ["eXPressor", "1.3", -1, 0xf51eba68, 1],
        ["eXPressor", "1.3", -1, 0xbc84ce09, 1],
        ["eXPressor", "1.4.5.X", 0, 0x427816ab, 1],
        ["eXPressor", "1.4.5.X", -1, 0x3c705cae, 1],
        ["eXPressor", "1.4.5.X", -1, 0x4d02e093, 1],
        ["eXPressor", "1.4.5.X", -1, 0x958a9ea2, 1], // VB6
        ["eXPressor", "1.5.0.X", -1, 0x7ababb5a, 1],
        ["eXPressor", "1.5.0.X", -1, 0x95ca15e4, 1],
        ["eXPressor", "1.5.0.X", -1, 0xbd41da20, 1],
        ["eXPressor", "1.6", -1, 0xca58fa0c, 1],
        ["eXPressor", "1.6.1", -1, 0x48ffd359, 1],
        ["VMProtect", "1.70", -1, 0x1ff3103f, 1],
        // ["VMProtect", "1.70", -1, 0x0c16df2d],
        ["VMProtect", "2.0.3-2.13", -1, 0x9d12b153, 1],
        ["VMProtect", "3.0.0", -1, 0x1e5500c1, 1],
        ["VMProtect", "3.0.9", -1, 0xc5fb6a4b, 1],
        ["VMProtect", "3.2.0-3.5.0", -1, 0x5caa99c7, 1],
        ["VMProtect", "3.6.0+", -1, 0x66e03954, 1],
        ["VMProtect", "3.6.0+", -1, 0xdae9f570, 1],
        ["YodasProtector", "1.0b", -1, 0x1303a51b, 1],
        ["ASM Guard", "2.XX+", -1, 0xf1e0d63b, 1], // https://github.com/DosX-dev/ASM-Guard
        ["Themida", "2.XX-3.XX", 0, 0x3ffccc8a, 1],
        ["Themida", null, 0, 0xad97c503, 1],
        ["Amber", null, -1, 0x97c72051, 1],
        [".NET Reactor", null, 0, 0x96be8e26, 1], // https://www.eziriz.com/dotnet_reactor.htm
        [".NET Reactor", null, 1, 0xb4cda32f, 1],
        ["Bat To Exe Converter", null, 0, 0x72a2ca64, 1],
        ["Vbs To Exe Converter", null, 0, 0x182aac68, 1],
        ["DNGuard", null, 0, 0x38432571, 1], // https://www.dnguard.net/
        ["DNGuard", "4.9+", 0, 0x99f8b58e, 1],
        ["obfus.h", null, -1, 0x02f4771f, 1], // https://github.com/DosX-dev/obfus.h  ;  default, antidebug v1
        ["Crunch", "1.0-2.0", 0, 0x615665dd, 1],
        ["Private EXE Protector", null, 0, 0xd89af68d, 1], // https://www.privacy-tutorials.com/private-exe-protector/
        ["CodeVirtualizer", null, 4, 0x4fbeea23, 1], // https://www.oreans.com/CodeVirtualizer.php
    ];

    const importValidatingResult = validateImportHashes(dbCollectionOfHashesDictionary);

    var versionByImportsDetected;

    if (importValidatingResult != null) {
        versionByImportsDetected = importValidatingResult[1];

        log(logType.nothing, "Imports hash like " + importValidatingResult[0] + (versionByImportsDetected ? " (version " + versionByImportsDetected + ")" : String()) + " (" + importValidatingResult[3] + ")")

        isImportsLikePacker = true;
    }

    // Clean up: release the dictionary
    dbCollectionOfHashesDictionary = undefined;

    if (isImportsLikePacker) options += (options ? " + " : String()) + "Imports like " + importValidatingResult[0] + (versionByImportsDetected ? " (v" + importValidatingResult[1] + ")" : String());




    var isSectionNameLikePacker = false;

    var dbCollectionOfSectionNamesDictionary = [
        [".NET Reactor", "2.XX", ".reacto"], // https://www.eziriz.com/dotnet_reactor.htm
        [".NET Reactor", null, ".reacto"],
        ["ACProtect", null, ".perplex"], // https://acprotect-standard.soft112.com/
        ["ANDpakk2", null, "ANDpakk2"],
        ["ASM Guard", "2.XX", ".asmg"], // https://github.com/DosX-dev/ASM-Guard
        ["ASM Guard", "2.XX", "ASMGUARD"],
        ["ASPack", "1.08-2.XX", ".adata"], // https://www.aspack.com/
        ["ASPack", "2.XX", ".aspack"],
        ["ASPack", null, ".ASPack"],
        ["ASPack", null, "ASPack"],
        ["Alienyze", null, ".alien"], // https://alienyze.com/
        ["Alloy", null, ".alloy32"],
        ["BoxedApp", null, ".bxpck"], // https://www.boxedapp.com/
        ["CodeVirtualizer", null, ".vlizer"], // https://www.oreans.com/CodeVirtualizer.php
        ["Crinkler", null, "lz32.dll"],
        ["Crunch", "2.0", "BitArts"],
        ["CrypToCrack", null, ".ccp3p"],
        ["DYAMAR", "1.3.5", ".dyamarC"],
        ["DxPack", "1.0", "coderpub"],
        ["Enigma", null, ".enigma1"], // https://enigmaprotector.com/
        ["Enigma", null, ".enigma2"],
        ["Epack", null, "!EPack"],
        ["Eronana", null, ".packer"],
        ["FishPE Shield", null, ".FishPE"],
        ["FishPE", null, ".FISHEP"],
        ["G!X Protector", null, ".g!x"],
        ["JDPack", null, ".jdpack"],
        ["Krypton", null, "YADO"],
        ["MEW", null, "MEW"],
        ["MPRESS", null, ".MPRESS1"], // https://www.autohotkey.com/mpress/mpress_web.htm
        ["MPRESS", null, ".MPRESS2"],
        ["MaskPE", null, ".MaskPE"],
        ["Morphnah", "1.0.X", ".nah"],
        ["NakedPacker", null, ".naked1"],
        ["NakedPacker", null, ".naked2"],
        ["NativeCryptor", null, "NATIVES~"],
        ["NeoLite", null, ".neolite"],
        ["NsPack", null, ".nsp0"], // https://nspack.apponic.com/
        ["NsPack", null, ".nsp1"],
        ["NsPack", null, "nsp0"],
        ["NsPack", null, "nsp1"],
        ["PE Diminisher", null, ".teraphy"], // https://web.archive.org/web/20060111104142/http://www.exetools.com/files/compressors/win/ped.zip
        ["PE-PACK", "1.0", "PEPACK!!"],
        ["PE-SHiELD", null, "PESHiELD"], // https://webscene.ir/tools/show/PE-SHIELD-0.25
        ["PEBundle", null, "PEBundle"], // https://bitsum.com/pebundle.htm
        ["PEBundle", null, "pebundle"],
        ["PECompact", null, "PEC2"], // https://bitsum.com/portfolio/pecompact/
        ["PECompact", null, "PEC2MO"],
        ["PECompact", null, "pec"],
        ["PECompact", null, "pec1"],
        ["PELock", null, "PELOCKnt"], // https://www.pelock.com/ 💩
        ["Perplex", null, ".perplex"],
        ["Petite", null, ".petite"], // https://www.un4seen.com/petite/
        ["Petite", null, "petite"],
        ["RLP", null, ".rlp"],
        ["RLPack", null, ".RLPack"],
        ["RLPack", null, ".packed"],
        ["SC Pack", null, ".scpack"],
        ["SVK Protector", null, "SVKP"],
        ["SVKP", null, ".svkp"],
        ["SafeNet", null, ".AKS1"],
        ["SafeNet", null, ".AKS2"],
        ["SafeNet", null, ".AKS3"],
        ["Safengine Shielden", null, ".sedat"],
        ["SecuROM", null, ".cms_d"], // https://en.wikipedia.org/wiki/SecuROM
        ["SecuROM", null, ".cms_t"],
        ["Shrinker", null, ".shrink1"],
        ["Simple Pack", null, ".spack"],
        ["Software Compress", null, "SoftComp"],
        ["StarForce", "3.X", ".sforce3"], // https://www.star-force.com/
        ["StarForce", "4.X-5.X", ".ps4"],
        ["Themida", "2.XX", "   "], // https://www.oreans.com/Themida.php
        ["Themida", "3.XX", ".imports"],
        ["Themida", "3.XX", ".loadcon"],
        ["Themida", "3.XX", ".themida"],
        ["Themida", "3.XX", ".winlice"],
        ["Themida", null, ".stub01"],
        ["Themida", null, "WinLicen"],
        ["Themida", null, ".v-lizer"],
        ["Themida", null, "Themida "],
        ["UPX", null, "UPX0"], // https://github.com/upx/upx
        ["UPX", null, "UPX1"],
        ["UPX", null, "UPX2"],
        ["UPX", null, "UPX3"],
        ["VCL", null, ".vcl"],
        ["VMProtect", null, ".vmp"], // https://vmpsoft.com/
        ["VMProtect", null, ".vmp0"],
        ["VMProtect", null, ".vmp1"],
        ["VMProtect", null, ".vmp2"],
        ["VMProtect", null, ".vmp3"],
        ["VirtualizeProtect", null, "VProtect"],
        ["WWPack", null, ".WWPACK"],
        ["WWPack32", null, ".WWP32"],
        ["Warbird", null, "?g_Encry"], // https://security-explorations.com/microsoft-warbird-pmp.html
        ["WinUPack", null, ".ByDwing"],
        ["WinUPack", null, ".Upack"],
        ["YodasCrypter", "1.X", "yC"], // https://sourceforge.net/projects/yodap/files/Yoda%20Crypter/1.3/yC1.3.zip/download
        ["YodasProtector", "1.0b", ".y0da"], // https://yodap.sourceforge.net/
        ["YodasProtector", "1.0b", ".yP"],
        ["dePack", "1.3.5", ".depack"],
        ["eXPressor", null, ".ex_cod"], // https://www.cgsoftlabs.ro/express.html
        ["eXPressor", null, ".ex_rsc"],
        ["hmimys", "1.3", "hmimys"],
        ["kkrunchy", null, "kkrunchy"], // https://www.farbrausch.de/~fg/kkrunchy/
        ["nPack", null, ".nPack"],
        ["obfus.h", null, ".obfh"], // https://github.com/DosX-dev/obfus.h
        ["tElock", null, "UPX!"], // https://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/Telock.shtml
        ["yzPack", null, ".yzpack2"],
        ["Inquartos Obfuscator", null, ".inq"],
        ["Wise Installer", null, ".wise"], // https://wpkg.org/WISE_installer
        ["Gentee Installer", null, ".gentee"], // https://www.gentee.com/download/
        ["Nullsoft Installer", null, ".ndata"], // https://sourceforge.net/projects/nsis/
        ["WiX Installer", null, ".wixburn"], // https://github.com/wixtoolset
        ["BeRoEXEPacker", null, "packerBY"], // https://blog.rosseaux.net/page/875fbe6549aa072b5ee0ac9cefff4827/BeRoEXEPacker
        ["NeoLite", null, ".neolit"],
        ["Private EXE Protector", null, ".-PEP-"],
        ["bambam", null, ".bedrock"],
        ["WibuKey", null, ".wibu"],
        ["Wibu CodeMeter", null, "__wibu00"],
        ["Wibu CodeMeter", null, "__wibu01"],
        ["AverCryptor", "1.0-1.02", ".avc"],
        ["Huan", null, ".huan"],
        ["Morphnah", "1.0.X", ".nah"],
        ["TSULoader", null, ".tsustub"],
        ["RPCrypt", null, ".RCryptor"],
        ["RPCrypt", null, ".RPCrypt"],
        ["AtomPePacker", null, ".ATOM"],
        ["DotFix NiceProtect", null, "."]
    ];

    const sectionNamesValidatingResult = validateSectionNames(dbCollectionOfSectionNamesDictionary);

    var versionBySectionDetected;

    if (sectionNamesValidatingResult != null) {
        versionBySectionDetected = sectionNamesValidatingResult[1];

        log(logType.nothing, "Sections like " + sectionNamesValidatingResult[0] + (versionBySectionDetected ? " (v" + versionBySectionDetected + ")" : String()));

        isSectionNameLikePacker = true;
    }

    // Clean up: release the dictionary
    dbCollectionOfSectionNamesDictionary = undefined;

    if (isSectionNameLikePacker) options += (options ? " + " : String()) + "Sections like " + sectionNamesValidatingResult[0] + (versionBySectionDetected ? " (v" + sectionNamesValidatingResult[1] + ")" : String());




    // Check if there is a collision in sections

    var isCollisionInSectionsPresent = false;

    // Get section name collision between "0" and "1"
    const sectionNameCollision = PE.getSectionNameCollision("0", "1");

    // Check if there is a collision
    if (sectionNameCollision.length) {
        log(logType.nothing, "Section names collision: '" + clearSectionName(sectionNameCollision) + "'");

        isCollisionInSectionsPresent = true;
    }

    if (isCollisionInSectionsPresent) options += (options ? " + " : String()) + "Sections collision (\"" + clearSectionName(sectionNameCollision) + "\")";




    // Check if there are repeating section names

    var isSectionNamesRepeatingPresent = false;

    var sectionCount = PE.getNumberOfSections(),
        sectionNamesDictionary = {};

    for (var i = 0; i < sectionCount && !isSectionNamesRepeatingPresent; i++) {
        var sectionName = PE.getSectionName(i);
        sectionNamesDictionary[sectionName] = (sectionNamesDictionary[sectionName] || 0) + 1;
        if (sectionNamesDictionary[sectionName] > 1) {
            log(logType.nothing, "Section names repeating: '" + clearSectionName(sectionName) + "'");

            isSectionNamesRepeatingPresent = true;
        }
    }

    if (isSectionNamesRepeatingPresent) options += (options ? " + " : String()) + "Section names repeating";




    // Check for 'MZ' signature in the overlay

    var isMzSignatureDetected = false;

    if (PE.isOverlayPresent() &&
        PE.getOverlaySize() >= 100 &&
        PE.compareOverlay("'MZ'")) {
        log(logType.any, "PE signature at overlay detected");

        isMzSignatureDetected = true;
    }

    if (isMzSignatureDetected) options += (options ? " + " : String()) + "PE in overlay";




    // Check for a strange overlay in the PE file

    var hasStrangeOverlay = false;

    // Conditions to check for a strange overlay
    if (!isMzSignatureDetected && !isSfx && !PE.isSigned() && PE.isOverlayPresent()) {
        var overlayEntropy = PE.calculateEntropy(PE.getOverlayOffset(), PE.getOverlaySize());
        if (
            PE.getOverlaySize() > 150 && overlayEntropy > 7 ||
            PE.getOverlaySize() > (PE.getSize() - PE.getOverlaySize())
        ) {
            log(logType.any, "Overlay size: " + PE.getOverlaySize() + " bytes; Entropy: " + overlayEntropy);

            hasStrangeOverlay = true;
        }
    }

    if (hasStrangeOverlay) options += (options ? " + " : String()) + "Strange overlay";




    // Flag to indicate high entropy

    var isHighEntropy = false;

    // Checks for high entropy (ignore overlay)
    if (!(PE.isDll() && (PE.section[".rdata"] || PE.isSectionNamePresent(".rsrc"))) && // .dll with resources
        PE.calculateEntropy(0x00, PE.getSize() - PE.getOverlaySize()) > 7.3) {
        isHighEntropy = true;
    }

    if (isHighEntropy) options += (options ? " + " : String()) + "High entropy";




    // Check for compressed sections using entropy

    var isCompressedSectionPresent = false;

    var sectionNumber = 0;

    for (var t = 0; t < PE.getNumberOfSections() && !isCompressedSectionPresent; t++) {
        sectionNumber = t;
        if (PE.calculateEntropy(PE.getSectionFileOffset(sectionNumber), PE.getSectionFileSize(sectionNumber)) > 7.4) {
            isCompressedSectionPresent = true;
        }
    }

    if (isCompressedSectionPresent) options += (options ? " + " : String()) + "Section " + sectionNumber + " (\"" + clearSectionName(PE.getSectionName(sectionNumber)) + "\") compressed";




    // Check for recurring import names

    var recurringImports = false;

    var importCount = PE.getNumberOfImports(),
        importNames = {};

    for (var i = 0; i < importCount && !recurringImports; i++) {
        var name = PE.getImportLibraryName(i);
        importNames[name] = (importNames[name] || 0) + 1;
        if (importNames[name] >= 3) {
            log(logType.nothing, "Recurring import name: \"" + name + "\"");

            recurringImports = true;
        }
    }

    if (recurringImports) options += (options ? " + " : String()) + "Recurring import names";




    if (isImportsLikePacker && !_getNumberOfResults("packer") && !_getNumberOfResults("protector") && !_getNumberOfResults("protection")) {
        var typeOfDetectedItem = String();

        switch (importValidatingResult[4]) {
            case 0: typeOfDetectedItem = "packer"; break;
            case 1: typeOfDetectedItem = "protector"; break;
            case 2: typeOfDetectedItem = "protection"; break;
        }

        if (typeOfDetectedItem) {
            var version = String(),
                importAndSectionValidationVerdictsDiffer = false;

            if (importValidatingResult[1]) {
                version = importValidatingResult[1];
            } else if (isSectionNameLikePacker) {
                if (importValidatingResult[0] === sectionNamesValidatingResult[0]) { // is same result
                    if (sectionNamesValidatingResult[1]) {
                        version = sectionNamesValidatingResult[1];
                    }
                } else { // Inconsistency of verdicts
                    importAndSectionValidationVerdictsDiffer = true;
                }
            }

            _setResult("~" + typeOfDetectedItem, importValidatingResult[0] + (importAndSectionValidationVerdictsDiffer ? "-like" : String()), version, "Suspicion only");
        }
    }




    if (options.length != 0) isDetected = true;


    if (isDetected) {
        var detectedType = isCryptor ? "cryptor" : "packer";

        _setResult("~" + detectedType, "Generic", String(), PE.isVerbose() ? options : String());
    }
}




function scanForLicensingSystems_NET_and_Native() { // For .NET and Native apps
    var options = String();

    var isDetected = Boolean();




    if (PE.isNet()) {

        var isLicenseCheckingPresent = false;

        if (PE.isNetObjectPresent("CheckLicense") || PE.isNetObjectPresent("set_License") || PE.isNetObjectPresent("Licensing")) {
            isLicenseCheckingPresent = true;
        }

        if (isLicenseCheckingPresent) options = "DotNET methods";




        // https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.licenseproviderattribute

        var isLicenseProviderPresent = false;

        if (PE.isNetObjectPresent("LicenseProviderAttribute")) {
            isLicenseProviderPresent = true;
        }

        if (isLicenseProviderPresent) options += (options ? " + " : String()) + "Provider attribute";




        // https://learn.microsoft.com/ru-ru/dotnet/api/system.componentmodel.licensemanager

        var isLicenseManagerPresent = false;

        if (PE.isNetObjectPresent("LicenseManager")) {
            isLicenseManagerPresent = true;
        }

        if (isLicenseManagerPresent) options += (options ? " + " : String()) + "License manager";

    }




    // Check for licensing strings

    var isInterestingStringsFound = false;

    const licesingStrings = [ /*[E]*/ "nter serial ", /*[S]*/ "erial key ", " activate ", " trial ", /*[W]*/ "rong activation", /*[W]*/ "rong licens", /*[L]*/ "icense expire", "valid license", /*[L]*/ "icense key", " full version", " purchase a "];

    for (var i = 0; i < licesingStrings.length; i++) {
        const currentPatternToFind = licesingStrings[i];

        if (PE.isSignaturePresent(0x00, PE.getSize(), "'" + currentPatternToFind + "'") ||
            PE.isSignaturePresent(0x00, PE.getSize(), "'" + generateUnicodeSignatureMask(currentPatternToFind) + "'")) {
            isInterestingStringsFound = true;
            break;
        }
    }

    if (isInterestingStringsFound) options += (options ? " + " : String()) + "Strings";




    var isDenuvoLibraryPresent = false;

    if (PE.isLibraryPresentExp(/(Core\\Activation|Activation64)/i)) {
        isDenuvoLibraryPresent = true;
    }

    if (isDenuvoLibraryPresent) options += (options ? " + " : String()) + "Denuvo DRM";




    if (options.length != 0) isDetected = true;


    if (isDetected) {
        _setResult("~licensing", "Contains", String(), PE.isVerbose() ? options : String());
    }
}



function scanForBadFileFormat_NET_and_Native() {
    var options = String();

    var isDetected = Boolean();




    // EP check

    var isEntryPointIncorrect = false;

    if (!PE.isEntryPointCorrect()) {
        isEntryPointIncorrect = true;
    }

    if (isEntryPointIncorrect) options += (options ? " + " : String()) + "EntryPoint";




    // Section alignment check

    var isSectionAlignmentIncorrect = false;

    if (!PE.isSectionAlignmentCorrect()) {
        isSectionAlignmentIncorrect = true;
    }

    if (isSectionAlignmentIncorrect) options += (options ? " + " : String()) + "Section aligment";




    // File alignment check

    var isFileAlignmentIncorrect = false;

    if (!PE.isFileAlignmentCorrect()) {
        isFileAlignmentIncorrect = true;
    }

    if (isFileAlignmentIncorrect) options += (options ? " + " : String()) + "File alignment";




    // Check for correct header

    var isHeaderIncorrect = false;

    if (!PE.isHeaderCorrect()) {
        isHeaderIncorrect = true;
    }

    if (isHeaderIncorrect) options += (options ? " + " : String()) + "Header";




    // Check for correct section headers

    var isRelocsTableIncorrect = false;

    if (!PE.isRelocsTableCorrect()) {
        isRelocsTableIncorrect = true;
    }

    if (isRelocsTableIncorrect) options += (options ? " + " : String()) + "Relocs";




    // Check IAT (Import Address Table)
    // Can be destroyed when the PE dumped from memory

    var isImportTableIncorrect = false;

    if (!PE.isImportTableCorrect()) {
        isImportTableIncorrect = true;
    }

    if (isImportTableIncorrect) options += (options ? " + " : String()) + "IAT";




    // Check EAT (only for .dll)

    var isExportTableIncorrect = false;

    if (PE.isDll() && !PE.isExportTableCorrect()) {
        isExportTableIncorrect = true;
    }

    if (isExportTableIncorrect) options += (options ? " + " : String()) + "EAT";




    // Check for resources table

    var isResourcesTableIncorrect = false;

    if (!PE.isResourcesTableCorrect()) {
        isResourcesTableIncorrect = true;
    }

    if (isResourcesTableIncorrect) options += (options ? " + " : String()) + "Resources";




    if (options.length != 0) isDetected = true;


    if (isDetected) {
        _setResult("~corrupted data", "Generic", String(), PE.isVerbose() ? options : String());
    }
}



function scanForDebugData_NET_and_Native() { // For .NET and Native apps
    var options = String();

    var isDetected = Boolean();




    // Check for sections with debug data by name

    var isDebugSectionPresent = false;

    var sectionNumber = 0;

    for (var i = 0; i < PE.getNumberOfSections() && !isDebugSectionPresent; i++) {
        sectionNumber = i;

        const currentSectionName = PE.getSectionName(i).toLowerCase();

        if (currentSectionName.indexOf("debug") !== -1 || // Modern LLVM debug sections
            currentSectionName === ".stab" || currentSectionName === ".stabstr") { // TCC/GCC
            log(logType.any, "Debug section detected: \"" + clearSectionName(PE.getSectionName(sectionNumber)) + "\"");
            isDebugSectionPresent = true;
        }
    }

    if (isDebugSectionPresent) options = "Section " + sectionNumber + " (\"" + clearSectionName(PE.getSectionName(sectionNumber)) + "\")";




    // .NET Native debug header, EAT function

    var isNetNativeDebugDataPresent = false;

    if (!PE.isNet() && PE.isExportFunctionPresent("DotNetRuntimeDebugHeader")) {
        log(logType.any, ".NET Native debug symbols detected");

        isNetNativeDebugDataPresent = true;
    }

    if (isNetNativeDebugDataPresent) options += (options ? " + " : String()) + "DotNET runtime header";




    // Check for -Wl,--export-all-symbols linker option

    var isSymbolsExported = false;

    if (!PE.isDll() && PE.isExportFunctionPresent("main")) {
        log(logType.any, "The \"--export-all-symbols\" linker option was probably used");

        isSymbolsExported = true;
    }

    if (isSymbolsExported) options += (options ? " + " : String()) + "Symbols exported";




    // Check for absolute PDB path

    var isPdbFullPathPresent = false;

    var pdbExtensionPatternOffset = PE.findSignature(PE.getDosStubOffset() + PE.getDosStubSize(), PE.getSize() - PE.getOverlaySize(), "'.pdb' 00");

    var pdbPathBeginOffset, pdbPath = String();

    if (pdbExtensionPatternOffset !== -1) {

        for (var i = pdbExtensionPatternOffset; i > 0; i--) {
            if (PE.readByte(i) === 0x00) {
                pdbPathBeginOffset = i + 1;
                break;
            }
        }

        pdbPath = PE.getString(pdbPathBeginOffset, 256);

        if (pdbPath.length > 255)
            pdbPath = pdbPath.substring(0, 255) + " . . .";

        pdbPath = pdbPath.replace(/[\n\r]/g, "");

        if (pdbPath.match(/^[a-zA-Z]:\\/) !== null) {
            log(logType.any, "PDB absolute path: \"" + pdbPath + "\"");

            isPdbFullPathPresent = true;
        }
    }

    if (isPdbFullPathPresent) options += (options ? " + " : String()) + "Absolute PDB path";




    // Check for portable (relative path) or embedded PDB

    var isPortableOrEmbeddedPdbDetected = false;

    var pdbTextType = String();

    if (pdbPath && pdbPath[0] !== '.' && !isPdbFullPathPresent) {
        pdbTextType = validateSignature("00 52 53 44 53") ? "Embedded" : "Portable";

        log(logType.any, pdbTextType + " PDB name: \"" + pdbPath + "\"");

        isPortableOrEmbeddedPdbDetected = true;
    }

    if (isPortableOrEmbeddedPdbDetected) options += (options ? " + " : String()) + pdbTextType + " PDB (release)";




    // Check for Costura.Fody embedded PDB. It is a .NET tool (library) that embeds DLL builds into the main assembly.

    var isCosturaEmbeddedDebugData = false;

    if (PE.isNet() && PE.isNetObjectPresent("costura.costura.pdb.compressed")) {
        log(logType.any, "Costura embedded PDB detected");

        isCosturaEmbeddedDebugData = true;
    }

    if (isCosturaEmbeddedDebugData) options += (options ? " + " : String()) + "Costura.Fody embedded PDB";




    if (options.length != 0) isDetected = true;


    if (isDetected) {
        _setResult("~debug data", "Contains", String(), PE.isVerbose() ? options : String());
    }
}



/**
 * Checks if the .NET Visual Basic standard library is present.
 *
 * @returns {boolean} True if the Microsoft.VisualBasic library is found; otherwise false.
 */
function isVbNetStandartLibraryPresent() {
    return PE.isNetObjectPresent("Microsoft.VisualBasic");
}



/**
 * Determines if the current PE file is a .NET component.
 *
 * @returns {boolean} Returns true if the PE file is identified as a .NET component, otherwise false.
 */
function isFrameworkComponent() {
    if (!PE.isNet() || !PE.isDll() || PE.isNetGlobalCctorPresent()) {
        return false;
    }

    const
        buildAssemblyName = PE.getNetAssemblyName(),
        buildModuleName = PE.getNetModuleName();

    if (buildAssemblyName.length >= 6 && buildAssemblyName.substring(0, 6) === "System" && buildModuleName === (buildAssemblyName + ".dll")) {
        return true;
    }

    return false;
}



/**
 * Validates the presence of a signature (pattern) within a specified range in a PE file.
 *
 * Searches for the given pattern starting from the DOS stub end until the PE size excluding the overlay.
 * Logs a message if the pattern is found and returns a boolean indicating the result.
 *
 * @param {string} pattern - The pattern to search for within the file.
 * @returns {boolean} True if the pattern is found, false otherwise.
 */
function validateSignature(pattern) {
    const
        offsetFound = PE.findSignature(PE.getDosStubOffset() + PE.getDosStubSize(), PE.getSize() - PE.getOverlaySize(), pattern),
        resultBool = offsetFound != -1;

    if (resultBool) {
        lastOffsetDetected = "0x" + Number(offsetFound).toString(16);
        log(logType.any, "Pattern found: " + pattern);
    }
    return resultBool;
}



/**
 * Searches all sections in the current PE file for the specified byte code.
 * If discovered, logs the offset at which it appears and returns true.
 * 
 * @param {string} byteCode - The byte code signature to locate.
 * @returns {boolean} True if the byte code is found in any section, otherwise false.
 */
function validateNetByteCode(byteCode) {
    for (var s = 0; s < PE.getNumberOfSections(); s++) {
        const
            sectionOffset = PE.getSectionFileOffset(s),
            sectionSize = PE.getSectionFileSize(s);

        var offsetFound = PE.findSignature(sectionOffset, sectionOffset + sectionSize, byteCode);
        if (offsetFound != -1) {
            lastOffsetDetected = "0x" + Number(offsetFound).toString(16);
            log(logType.net, "ByteCode detected: " + byteCode);
            return true;
        }
    }
    return false;
}



/**
 * Validates if the given object is a .NET object.
 *
 * @param {Object} object - The object to be validated.
 * @returns {boolean} - Returns true if the object is a .NET object, otherwise false.
 */
function validateNetObject(object) {
    const result = PE.isNetObjectPresent(object);
    if (result) log(logType.net, "Object present: " + object);
    return result;
}



/**
 * Validates if a .NET Unicode string is present in the PE file.
 *
 * @param {string} ustring - The Unicode string to validate.
 * @returns {boolean} - Returns true if the Unicode string is present, otherwise false.
 */
function validateNetUnicodeString(ustring) {
    const result = PE.isNetUStringPresent(ustring);
    if (result) log(logType.net, "String present: \"" + ustring + "\"");
    return result;
}



/**
 * Validates if a given Unicode string exists within the PE file.
 *
 * This function searches for the specified Unicode string within the PE file's
 * memory range, excluding the DOS stub and overlay sections. If the string is
 * found, it logs a message indicating the presence of the string.
 *
 * @param {string} ustring - The Unicode string to search for within the PE file.
 * @returns {boolean} - Returns true if the Unicode string is found, otherwise false.
 */
function validateGlobalUnicodeString(ustring) {
    const result = PE.findSignature(PE.getDosStubOffset() + PE.getDosStubSize(), PE.getSize() - PE.getOverlaySize(), generateUnicodeSignatureMask(ustring)) != -1;
    if (result) log(logType.nothing, "Unicode string found: \"" + ustring + "\"");
    return result;
}



/**
 * Generates a Unicode signature mask for the given input string.
 *
 * This function iterates through each character in the input string and appends
 * its Unicode representation to the output string. The first character is appended
 * without a prefix, while subsequent characters are prefixed with "00".
 * 
 * "test" -> "'t'00'e'00's'00't'"
 *
 * @param {string} ustring - The input string for which to generate the Unicode signature mask.
 * @returns {string} The generated Unicode signature mask.
 */
function generateUnicodeSignatureMask(ustring) {
    var output = String();

    // Iterate through each character in the input string
    for (var c = 0; c < ustring.length; c++) {
        // Append the Unicode representation of the character to the output
        output += (c != 0 ? "00" : String()) + "'" + ustring[c] + "'";
    }

    // Return the generated Unicode signature mask
    return output;
}



/**
 * Checks if all .NET references in the provided array are missing.
 *
 * @param {Array} references - An array of .NET references to check.
 * @returns {boolean} - Returns true if all .NET references are missing, otherwise false.
 */
function isAllNetReferencesMissing(references) {
    // Iterate through the array of .NET references
    for (var i = 0; i < references.length; i++) {
        // Get the current reference
        const ref = references[i];

        // If the .NET object corresponding to the reference is present, return false
        if (PE.isNetObjectPresent(ref)) {
            return false;
        }
    }

    // If all .NET references are missing, return true
    return true;
}



/**
 * Checks if all .NET references are present.
 *
 * @param {Array} references - An array of .NET references to check.
 * @returns {boolean} - Returns true if all .NET references are present, otherwise false.
 */
function isAllNetReferencesPresent(references) {
    // Iterate through the array of .NET references
    for (var i = 0; i < references.length; i++) {
        // Get the current reference
        const ref = references[i];

        // If the .NET object corresponding to the reference is not present, return false
        if (!PE.isNetObjectPresent(ref)) {
            return false;
        }
    }

    // If all .NET references are present, return true
    return true;
}



/**
 * Searches for a signature in the first section of a PE file and marks it if found.
 *
 * @param {string} sign - The signature to search for.
 * @param {boolean} isFullName - A flag indicating whether to append '00' to the signature.
 * @returns {string} - The found signature if present, otherwise an empty string.
 */
function findAndMark(sign, isFullName) {
    if (PE.isSignatureInSectionPresent(0,
        ("00'" + sign + "'") + // 00'string
        (isFullName ? "00" : String()))) { // ... '00
        return sign;
    }
    return String();
}



/**
 * Determines if a given string name is obfuscated.
 *
 * The function checks for obfuscation in two cases:
 * 1. If the name contains spaces, it splits the name into tokens and checks each token for obfuscation.
 * 2. If the name does not contain spaces, it checks each chunk of the string (of size 20) for obfuscation.
 *
 * Logs a message if an obfuscated segment or chunk is found.
 *
 * @param {string} name - The string to analyze for obfuscation.
 * @returns {boolean} True if the name or any of its segments/chunks are obfuscated, false otherwise.
 */
function isNameObfuscated(name) {
    if (!name || name.length === 0) return false;

    if (name.indexOf(' ') !== -1) {
        const tokens = name.split(/\s+/);
        for (var i = 0; i < tokens.length; i++) {
            if (isTokenObfuscated(tokens[i])) {
                log(logType.nothing, "Obfuscated string segment: \"" + tokens[i] + "\" in \"" + name + "\"");
                return true;
            }
        }
        return false;
    }

    // Split the name into chunks
    const CHUNK_SIZE = 20;

    for (var start = 0; start < name.length; start += CHUNK_SIZE) {
        const chunk = name.substring(start, start + CHUNK_SIZE);
        if (isTokenObfuscated(chunk)) {
            log(logType.nothing, "Obfuscated string chunk: \"" + chunk + "\" in \"" + name + "\"");
            return true;
        }
    }

    return false;
}



/**
 * Determines whether a given token is considered obfuscated based on advanced heuristics.
 * 
 * The function checks for:
 * - Tokens shorter than 7 characters are automatically considered clean
 * - Hexadecimal strings (8+ chars) like 'd3adc0de'
 * - Regular expression patterns indicating mixed alphanumeric sequences with:
 *   - Minimum 4 digits
 *   - Letter-digit-letter pattern
 * - Statistical character analysis requiring either:
 *   - 7+ digits (absolute count)
 *   - High digit density (>35% of total characters)
 *   - Balanced mix (5+ digits, 3+ lowercase AND 3+ uppercase)
 *   - Digit-heavy with lowercase (5+ digits, 5+ lowercase)
 *
 * @param {string} token - The string token to analyze
 * @returns {boolean} True if token matches obfuscation patterns, false otherwise
 */
function isTokenObfuscated(token) {
    if (!token || token.length < 7) return false;

    if (token.match(/^(?=\d|[a-z])(?=.*[a-z]\d[a-z])(?=(?:.*\d){4,})/i)) {
        return true;
    }

    var stats = { digits: 0, lower: 0, upper: 0 };

    for (var i = 0; i < token.length; i++) {
        var char = token[i];
        if (char >= '0' && char <= '9') {
            stats.digits++;
        } else if (char >= 'a' && char <= 'z') {
            stats.lower++;
        } else if (char >= 'A' && char <= 'Z') {
            stats.upper++;
        }
    }

    if (token.match(/^[0-9a-f]{8,}$/i)) return true;  // Detects hashes like d3adc0de

    const totalChars = token.length;

    return (
        (stats.digits >= 7) ||
        (stats.digits >= 4 && stats.digits / totalChars > 0.35) ||
        (stats.digits >= 5 && stats.lower >= 3 && stats.upper >= 3) ||
        (stats.digits >= 6 && stats.lower >= 5)
    );
}



function scanForObfuscations_Native() {
    var options = String();

    var isDetected = Boolean();




    // Check for section names containing forbidden characters

    var isStrangeSectionsPresent = false;

    // Define forbidden characters
    const badSectionChars = '-=+~!@#$%^&*()"№;%:?*():;,/\\|\'`<> ';

    // Iterate through sections and characters to check for forbidden characters
    for (var i = 0; i < PE.getNumberOfSections() && !isStrangeSectionsPresent; i++) {
        var sectionName = PE.getSectionName(i);

        if (sectionName.length === 0 || sectionName[0] === " ") {
            isStrangeSectionsPresent = true;
        }

        var isIdioticMinGwSectionsPresent = false;

        if (_isResultPresent("linker", "GNU linker ld (GNU Binutils)")) {
            if (PE.isSectionNamePresent(".build-id")) {
                isIdioticMinGwSectionsPresent = true;
            } else {
                for (var d = 1; d < 10 && !isIdioticMinGwSectionsPresent; d++) { // sections like "/5", "/2" etc
                    if (sectionName.indexOf("/" + d) != -1) {
                        isIdioticMinGwSectionsPresent = true;
                    }
                }
            }
        }

        if (isIdioticMinGwSectionsPresent) {
            isStrangeSectionsPresent = false;
            break;
        }

        for (var d = 0; d < badSectionChars.length && !isStrangeSectionsPresent; d++) {
            // If forbidden character is found, set flag and break
            if (sectionName.indexOf(badSectionChars[d]) !== -1) {
                isStrangeSectionsPresent = true;
            }
        }

        if (!isAnsiString(sectionName) && !isStrangeSectionsPresent) {
            isStrangeSectionsPresent = true;
        }
    }

    if (isStrangeSectionsPresent) options += (options ? " + " : String()) + "Strange sections";




    // Check for DOS header in the PE file

    var isDosMissing = false,
        isCustomDosPresent = false;

    // If DOS stub size is 0, set flag for missing DOS
    if (PE.getDosStubSize() === 0) {
        isDosMissing = true;
    } else {
        // Define messages to check for custom DOS
        const messages = [
            "This program cannot be run in DOS mode.", // most popular (standart)
            "This program must be run under Win32",
            "This program must be run under Win64",
            "This program requires Win32",
            "This is a Windows NT character-mode executable" // Watcom C/C++
        ];

        isCustomDosPresent = true;

        // Iterate through messages to check for custom DOS
        for (var d in messages) {
            if (isCustomDosPresent) {
                if (PE.findSignature(PE.getDosStubOffset(), PE.getDosStubSize(), "'" + messages[d] + "'") != -1) {
                    isCustomDosPresent = false;
                }
            }
        }
    }

    // Add appropriate option based on DOS presence
    if (isDosMissing) options += (options ? " + " : String()) + "Missing DOS";
    else if (isCustomDosPresent) options += (options ? " + " : String()) + "Custom DOS";




    // It works if the file contains an import without an extension (for example, instead of "kernel32.dll" it is written "kernel32").
    // Compilers don't do that

    var isContainsNoExtensionLibrary = false;

    for (var i = 0; i < PE.getNumberOfImports() && !isContainsNoExtensionLibrary; i++) {
        const libraryName = PE.getImportLibraryName(i).toLowerCase();

        if (libraryName.length > 4) {
            if (libraryName[libraryName.length - 4] !== ".") {
                isContainsNoExtensionLibrary = true;
            }
        } else { /* if (libraryName.indexOf(".") === -1) */
            isContainsNoExtensionLibrary = true;
        }
    }

    if (isContainsNoExtensionLibrary) options += (options ? " + " : String()) + "No extension import";




    // .exe files in imports are a separate type of sophistication. But this happens.

    var exeInImports = false;

    for (var i = 0; i < PE.getNumberOfImports() && !exeInImports; i++) {
        const libraryName = PE.getImportLibraryName(i).toLowerCase();

        if (libraryName.length > 4) {
            if (libraryName !== "ntoskrnl.exe" && libraryName.substr(libraryName.length - 4, 4) === ".exe") {
                exeInImports = true;
            }
        }
    }

    if (exeInImports) options += (options ? " + " : String()) + "EXE in imports";




    // Looks for sections whose names contain strange (or invalid) characters

    var isInvalidImportsPresent = false;

    const badImportChars = '=~!@#$%^&*()"№;%:?*():;,|\'`<> ';

    for (var i = 0; i < PE.getNumberOfImports() && !isInvalidImportsPresent; i++) {
        const libraryName = PE.getImportLibraryName(i).toLowerCase();

        for (var l = 0; l < badImportChars.length && !isInvalidImportsPresent; l++) {
            if (libraryName.indexOf(badImportChars[l]) !== -1) {
                isInvalidImportsPresent = true;
            }
        }
    }

    if (isInvalidImportsPresent) options += (options ? " + " : String()) + "Invalid imports";




    // Checks if application resources can be read or if they are compressed/encrypted

    var isUnreadableResourcesPresent = false;

    for (var i = 0; i < PE.getNumberOfResources() && !isUnreadableResourcesPresent; i++) {
        if (PE.getResourceOffsetByNumber(i) === -1)
            isUnreadableResourcesPresent = true;
    }

    if (isUnreadableResourcesPresent) options += (options ? " + " : String()) + "Unreadable resources";




    // Checks is executable application has been compiled or converted to a DLL
    // Like https://github.com/hasherezade/exe_to_dll

    var exeAsDll = false;

    if (PE.isDll() && (
        PE.isExportFunctionPresent("Start") ||
        PE.isExportFunctionPresent("main") ||
        PE.isExportFunctionPresent("_start"))) {
        exeAsDll = true;
    }

    if (exeAsDll) options += (options ? " + " : String()) + "EXE as DLL";




    // The .text section should always come first

    var isTextSectionNotFirst = false;

    if (PE.getNumberOfSections() > 0 && (PE.section[0].Name !== ".text" && PE.section[0].Name !== ".textbss") && (PE.isSectionNamePresent(".text") || PE.isSectionNamePresent(".textbss")) && PE.section[0] === ".code") {
        isTextSectionNotFirst = true;
    }

    if (isTextSectionNotFirst) options += (options ? " + " : String()) + "\".text\" section is not first";




    // If IAT (Import Address Table) is missing

    var isIatMissing = false;

    if (PE.getNumberOfImports() == 0 &&
        (!PE.isDll() && PE.getNumberOfSections() > 0 && PE.section[0].Name === ".text")) {
        isIatMissing = true;
    }

    if (isIatMissing) options += (options ? " + " : String()) + "No IAT";




    // Check if the entry point starts with NOP or a NOP-like instruction

    var isStartsWithNop = false;

    /**
     * NOP-equivalent instructions for x86/x64:
     *     * Standard NOP instructions:
     * - 0x90                                           -> NOP (standard 1-byte NOP)
     * - 0x66 0x90                                      -> XCHG AX, AX (2-byte NOP)
     * - 0x0F 0x1F 0x00                                 -> NOP DWORD PTR [EAX/RAX] (3-byte NOP)
     * - 0x0F 0x1F 0x40 0x00                            -> NOP DWORD PTR [EAX/RAX+0x00] (4-byte NOP)
     * - 0x0F 0x1F 0x44 0x00 0x00                       -> NOP DWORD PTR [EAX/RAX+EAX/RAX*1+0x00] (5-byte NOP)
     * - 0x66 0x0F 0x1F 0x44 0x00 0x00                  -> NOP WORD PTR [EAX/RAX+EAX/RAX*1+0x00] (6-byte NOP)
     * - 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00             -> NOP DWORD PTR [EAX/RAX+0x00000000] (7-byte NOP)
     * - 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00        -> NOP DWORD PTR [EAX/RAX+EAX/RAX*1+0x00000000] (8-byte NOP)
     * - 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00   -> NOP WORD PTR [EAX/RAX+EAX/RAX*1+0x00000000] (9-byte NOP)
     * 
     * Functional equivalents of NOP:
     * - 0x89 0xF6                       -> MOV ESI, ESI (x86)
     * - 0x48 0x89 0xF6                  -> MOV RSI, RSI (x64)
     * - 0x8D 0x76 0x00                  -> LEA ESI, [ESI+0x00] (x86)
     * - 0x48 0x8D 0x76 0x00             -> LEA RSI, [RSI+0x00] (x64)
     * - 0x8D 0x74 0x26 0x00             -> LEA ESI, [ESI+EIZ+0x00] (x86)
     * - 0x48 0x8D 0x74 0x26 0x00        -> LEA RSI, [RSI+RIZ+0x00] (x64)
     * - 0x87 0xDB                       -> XCHG EBX, EBX (x86)
     * - 0x48 0x87 0xDB                  -> XCHG RBX, RBX (x64)
     * - 0x87 0xC9                       -> XCHG ECX, ECX (x86)
     * - 0x48 0x87 0xC9                  -> XCHG RCX, RCX (x64)
     * - 0x87 0xD2                       -> XCHG EDX, EDX (x86)
     * - 0x48 0x87 0xD2                  -> XCHG RDX, RDX (x64)
     * - 0x87 0xFF                       -> XCHG EDI, EDI (x86)
     * - 0x48 0x87 0xFF                  -> XCHG RDI, RDI (x64)
     * - 0x87 0xC0                       -> XCHG EAX, EAX (x86)
     * - 0x48 0x87 0xC0                  -> XCHG RAX, RAX (x64)
     * - 0x8D 0x00                       -> LEA EAX, [EAX] (x86)
     * - 0x48 0x8D 0x00                  -> LEA RAX, [RAX] (x64)
     */

    // Universal NOP equivalents (work on both architectures)
    const nopEquivalentsUniversal = [
        "XCHG AX, AX",
        "XCHG BX, BX", "XCHG CX, CX", "XCHG DX, DX",
        "XCHG SI, SI", "XCHG DI, DI", "XCHG BP, BP"
    ];

    // Collections of NOP-equivalent instructions based on architecture
    const nopEquivalents32bit = [
        // x86
        "MOV ESI, ESI", "XCHG EAX, EAX",
        "XCHG EBX, EBX", "XCHG ECX, ECX",
        "XCHG EDX, EDX", "XCHG EDI, EDI",
        "LEA EAX, [EAX]", "LEA ESI, [ESI]",
        "LEA ESI, CS:[ESI]"
    ];

    const nopEquivalents64bit = [
        // x64
        "MOV RSI, RSI", "XCHG RAX, RAX",
        "XCHG RBX, RBX", "XCHG RCX, RCX",
        "XCHG RDX, RDX", "XCHG RDI, RDI",
        "LEA RAX, [RAX]", "LEA RSI, [RSI]",
        "LEA RSI, CS:[RSI]"
    ];

    // Combine universal and architecture-specific instructions
    const nopEquivalents = nopEquivalentsUniversal.concat(
        PE.is64() ? nopEquivalents64bit : nopEquivalents32bit
    );

    // First check for standard NOP opcode which covers all NOP variants with different operands
    if (getFirstEpAsmOpCode() === "NOP") {
        isStartsWithNop = true;
    } else {
        // Then check for all functional NOP equivalents that have different opcodes
        for (var i = 0; i < nopEquivalents.length; i++) {
            if (getFirstEpAsmInstruction() === nopEquivalents[i]) {
                isStartsWithNop = true;
                break;
            }
        }
    }

    if (isStartsWithNop) options += (options ? " + " : String()) + "Nop at EP";




    // Check for "Stack-push address near EP" (CALL $+5)

    var isAddrToStackTrickPresent = false;

    // Check first 30 instructions for "Stack-push address near EP"
    // This trick uses "CALL $+5" (E8 00 00 00 00) to push next instruction address on stack
    if (!PE.isDll()) {
        for (var i = 0; i < 30; i++) {
            var asmInstruction = getAsmInstructionByIndex(i);

            if (!asmInstruction) break; // Safety check

            // Check if instruction is CALL
            if (getAsmOpCode(asmInstruction) === "CALL") {
                // Get address and offset for this instruction
                var disasmAddress = PE.getAddressOfEntryPoint();

                for (var j = 0; j < i; j++) {
                    disasmAddress = PE.getDisasmNextAddress(disasmAddress);
                }

                var currentOffset = PE.VAToOffset(disasmAddress);

                // Check if machine code matches E8 00 00 00 00 pattern
                if (PE.compare("E8 00 00 00 00", currentOffset)) {
                    log(logType.any, "Stack-push address near EP found at offset: 0x" + currentOffset.toString(16));
                    isAddrToStackTrickPresent = true;
                    break;
                }
            }
        }
    }

    if (isAddrToStackTrickPresent) options += (options ? " + " : String()) + "Stack-push address near EP";




    // Check for CPUID at entry point

    var isCpuidNearEpPresent = false;

    // Check first 15 instructions for CPUID instruction
    if (!PE.isDll()) {
        for (var i = 0; i < 15; i++) {
            var asmInstruction = getAsmInstructionByIndex(i);

            if (!asmInstruction) break; // Safety check

            // Check if instruction is CPUID
            if (getAsmOpCode(asmInstruction) === "CPUID") {
                log(logType.any, "CPUID near EP found at instruction index: " + i);
                isCpuidNearEpPresent = true;
                break;
            }
        }
    }

    if (isCpuidNearEpPresent) options += (options ? " + " : String()) + "Cpuid near EP";




    // Check if NOP padding is present at the entry point

    var isNopPaddingPresent = false;

    // Condition to check for NOP padding
    if (!isStartsWithNop && getEpAsmPattern(onlyOpCodes = true, numberOf = 5).indexOf(getInstructionsAsmPattern(["NOP", "NOP"])) !== -1) {
        isNopPaddingPresent = true;
    }

    if (isNopPaddingPresent) options += (options ? " + " : String()) + "Nop EP padding";




    // Check for sections with full RWX permissions (Read, Write, Execute)

    var isRwxSectionPresent = false;

    var rwxSectionNumber = 0;

    const
        SECTION_FLAGS_EXECUTE = 0x20000000, // IMAGE_SCN_MEM_EXECUTE
        SECTION_FLAGS_READ = 0x40000000, // IMAGE_SCN_MEM_READ
        SECTION_FLAGS_WRITE = 0x80000000, // IMAGE_SCN_MEM_WRITE
        SECTION_FLAGS_CODE = 0x00000020; // IMAGE_SCN_CNT_CODE

    const
        RWX_MASK = SECTION_FLAGS_EXECUTE | SECTION_FLAGS_READ | SECTION_FLAGS_WRITE,
        RWX_CODE_MASK = RWX_MASK | SECTION_FLAGS_CODE;


    for (var i = 0; i < PE.getNumberOfSections() && !isRwxSectionPresent; i++) {
        var currentSectionCharacteristics = PE.section[i].Characteristics;

        if ((currentSectionCharacteristics & RWX_MASK) === RWX_MASK ||
            (currentSectionCharacteristics & RWX_CODE_MASK) === RWX_CODE_MASK) {
            isRwxSectionPresent = true;
            rwxSectionNumber = i;
        }
    }

    if (isRwxSectionPresent) options += (options ? " + " : String()) + "Section " + rwxSectionNumber + " (\"" + clearSectionName(PE.getSectionName(rwxSectionNumber)) + "\") has RWX";




    // Check for IAT directory presence

    var isIatDirEmpty = false;

    // Offset of the IAT directory (12 is the number of IMAGE_DIRECTORY_ENTRY_ entries, 8 is the size of each entry)
    const iatDirOffset = getOptHeaderOffset() + (PE.is64() ? 0x70 : 0x60) + 12 * 8;

    if (options && !isIatMissing && PE.read_int32(iatDirOffset) === 0) {
        isIatDirEmpty = true;
    }

    if (isIatDirEmpty) options += (options ? " + " : String()) + "IAT directory empty";




    // Check for unused exception section

    var isUnusedExceptionSectionPresent = false;

    if (PE.isSectionNamePresent(".pdata") || PE.isSectionNamePresent(".xdata")) {

        // Offset of the exception directory (12 is the number of IMAGE_DIRECTORY_ENTRY_ entries, 8 is the size of each entry)
        var exceptionDirOffset = getOptHeaderOffset() + (PE.is64() ? 0x88 : 0x78);

        if (PE.read_int32(exceptionDirOffset) === 0 && PE.read_int32(exceptionDirOffset + 4) === 0) {
            isUnusedExceptionSectionPresent = true;
        }
    }

    if (isUnusedExceptionSectionPresent) options += (options ? " + " : String()) + "Exceptions directory empty";




    // Check for .NET metadata presence

    var isNetMetaDataInNativePresent = false;

    if (isNetMetaDataPresent()) {
        isNetMetaDataInNativePresent = true;
    }

    if (isNetMetaDataInNativePresent) options += (options ? " + " : String()) + "DotNET meta";




    // ASM Guard fake signatures

    if (PE.section[".asmg"] || PE.section["ASMGUARD"]) {
        for (var f = 0; f < 3; f++)
            _removeResult("packer", ["UPX", "MPRESS", "EP:MPRESS"][f]);
    }




    if (options.length != 0) isDetected = true;


    if (isDetected) {
        _setResult("~protection", "Generic", String(), PE.isVerbose() ? options : String());
    }
}



const _patternSplitter = "|";

/**
 * Generates a pattern of assembly instructions or opcodes from the entry point.
 *
 * @param {boolean} onlyOpCodes - If true, only the opcodes of the instructions are included in the pattern.
 * @param {number} numberOf - The number of instructions to include in the pattern.
 * @returns {string} The generated assembly pattern.
 */
function getEpAsmPattern(onlyOpCodes, numberOf) {
    // Initialize the result with a pattern splitter
    var result = _patternSplitter;

    // Get the address of the entry point
    var disasmAddress = PE.getAddressOfEntryPoint();

    // Iterate through instructions up to the specified number
    for (var i = 0; i < numberOf; i++) {

        // Update the address to the next instruction if not the first iteration
        if (i >= 1) {
            disasmAddress = PE.getDisasmNextAddress(disasmAddress);
        }

        // Get the assembly instruction at the current address
        const asmInstruction = PE.getDisasmString(disasmAddress);

        // Append either the opcode or the full instruction to the result
        result += (
            onlyOpCodes ?
                getAsmOpCode(asmInstruction) : // "MOV"
                asmInstruction // "MOV EAX, 4"
        ) + _patternSplitter;
    }

    // Return the generated assembly pattern
    return result;
}



/**
 * Retrieves the assembly instruction at the specified index from the entry point of a PE file.
 *
 * @param {number} index - The index of the assembly instruction to retrieve.
 * @returns {string} The assembly instruction at the specified index.
 */
function getAsmInstructionByIndex(index) {
    // Get the address of the entry point
    var disasmAddress = PE.getAddressOfEntryPoint();

    // Iterate through instructions until the specified index is reached
    for (var i = 0; i <= index; i++) {

        // Update the address to the next instruction if not the first iteration
        if (i >= 1) {
            disasmAddress = PE.getDisasmNextAddress(disasmAddress);
        }

        // If the current iteration matches the specified index, retrieve the instruction
        if (i === index) {
            // Return the assembly instruction
            return PE.getDisasmString(disasmAddress);
        }
    }
}



/**
 * Generates a subpattern string to search for instructions within a pattern divided by a separator.
 *
 * This function allows you to create a subpattern that can be used to search for specific instructions
 * within a larger pattern string that is divided by a separator (_patternSplitter).
 *
 * Examples:
 * - "|OPCODE1|OPCODE2|OPCODE3|".indexOf("|OPCODE2|")
 * - "|OPCODE1|OPCODE2|OPCODE3|".indexOf(getInstructionsAsmPattern("OPCODE2"))
 * - "|OPCODE1|OPCODE2|OPCODE3|".indexOf("|OPCODE2|OPCODE3|")
 * - "|OPCODE1|OPCODE2|OPCODE3|".indexOf(getInstructionsAsmPattern(["OPCODE2", "OPCODE3"]))
 *
 * @param {string|string[]} instruction - The instruction or array of instructions to create the subpattern for.
 * @returns {string} The generated subpattern string.
 */
function getInstructionsAsmPattern(instruction) {
    return _patternSplitter +
        (
            Array.isArray(instruction) ?
                instruction.join(_patternSplitter) :
                instruction
        ) +
        _patternSplitter;
}



/**
 * Retrieves the first assembly instruction at the entry point of the PE file.
 *
 * @returns {string} The disassembled string of the first instruction at the entry point.
 */
function getFirstEpAsmInstruction() {
    return PE.getDisasmString(PE.OffsetToVA(PE.getEntryPointOffset()));
}



/**
 * Extracts the opcode from an assembly instruction.
 *
 * @param {string} instruction - The assembly instruction.
 * @returns {string} - The opcode of the instruction.
 */
function getAsmOpCode(instruction) {
    return instruction.indexOf(" ") !== -1 ? instruction.split(" ")[0] : instruction;
}



/**
 * Retrieves the first assembly operation code from the entry point of the executable.
 *
 * @returns {string} The assembly operation code of the first instruction at the entry point.
 */
function getFirstEpAsmOpCode() {
    return getAsmOpCode(getFirstEpAsmInstruction());
}



/**
 * Checks if an item pattern appears to be a mangled symbol name.
 * 
 * @param {string} itemPattern - The pattern string to check for mangling
 * @returns {boolean} True if the pattern appears to be a mangled symbol, false otherwise
 */
function isItemMangled(itemPattern) {
    // Check if the pattern is too short to be mangled
    if (itemPattern.length <= 5) {
        return false;
    }

    return (
        (itemPattern[0] === '?' && (itemPattern.indexOf("@@") !== -1 || itemPattern[1] === '?')) || // MSVC mangling: starts with '?' and contains "@@" or has double '?'
        (itemPattern.substring(0, 2) === "_Z") ||                                                   // GNU mangling: starts with "_Z"
        (itemPattern[0] === '@' && itemPattern.indexOf('$') !== -1)                                 // Borland C++ mangling: starts with '@' and contains '$'
    );
}



/**
 * Determines the name of the C++ name mangler based on the given mangled item pattern.
 *
 * @param {string} itemPattern - The mangled item pattern to analyze.
 * @returns {string|undefined} The name of the detected mangler ("Visual C++", "MinGW", "Borland C++"), or undefined if not recognized or not mangled.
 */
function getManglerNameByMangledItem(itemPattern) {
    if (!isItemMangled(itemPattern)) {
        return undefined;
    }

    // Visual C++ (MSVC)
    if (itemPattern[0] === '?') {
        return "Microsoft Visual C++";
    }

    // MinGW (GNU)
    if (itemPattern.substring(0, 2) === "_Z") {
        return "MinGW";
    }

    // Borland C++
    if (itemPattern[0] === '@' && itemPattern.indexOf('$') !== -1) {
        return "Borland C++";
    }

    return undefined;
}



/**
 * Extracts the unmangled name from a mangled C++ symbol.
 * 
 * This function handles both Microsoft Visual C++ (MSVC) and GNU C++ (GCC) name mangling schemes:
 * - MSVC mangled names start with '?' and include patterns for functions, constructors, destructors, operators, and templates
 * - GCC mangled names start with '_Z' and include patterns for STL functions, namespaced functions, and regular functions
 * 
 * @param {string} itemPattern - The mangled symbol name to decode
 * @returns {string} The unmangled function/symbol name, or the original pattern if it's not mangled or cannot be decoded
 * 
 * @example
 * // MSVC examples
 * getNameOfMangledItem('?myFunction@@YAXXZ') // returns 'myFunction'
 * getNameOfMangledItem('??0MyClass@@QAE@XZ') // returns 'MyClass' (constructor)
 * getNameOfMangledItem('??$myTemplate@H@@YAXXZ') // returns 'myTemplate'
 * 
 * @example
 * // GCC examples
 * getNameOfMangledItem('_Z9myFunctionv') // returns 'myFunction'
 * getNameOfMangledItem('_ZSt4cout') // returns 'cout'
 * getNameOfMangledItem('_ZN3std4cout') // returns 'cout'
 * 
 * @example
 * // Borland examples
 * getNameOfMangledItem('@func$qi') // returns 'func'
 * getNameOfMangledItem('@Class@method$qpc') // returns 'method'
 * getNameOfMangledItem('@Class@$bctr$qi') // returns 'Class' (constructor)
 */
function getNameOfMangledItem(itemPattern) {
    if (!isItemMangled(itemPattern)) {
        return itemPattern;
    }

    // MSVCPP mangled names start with '?'
    if (itemPattern[0] === '?') {
        // Regular function: ?myFunction@@YAXXZ
        if (itemPattern[1] !== '?') {
            return itemPattern.split("?")[1].split("@")[0];
        }

        // Handle all ?? patterns
        if (itemPattern[1] === '?') {
            var parts, nameWithPrefix;

            // Simple template: ??$myTemplate@H@@YAXXZ
            if (itemPattern[2] === '$') {
                return itemPattern.split("$")[1].split("@")[0];
            }

            // Complex template: ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
            if (itemPattern.indexOf('?$') !== -1) {
                var complexMatch = itemPattern.match(/\?\?\d\?\$([^@]+)@/);

                if (complexMatch) {
                    return complexMatch[1];
                }
            }

            // Special mangler: ??_7MyClass@@6B@, ??_EMyClass@@QAEPAXI@Z
            if (itemPattern[2] === '_') {
                parts = itemPattern.split("?");
                if (parts.length >= 3) {
                    nameWithPrefix = parts[2].split("@")[0];
                    // For _E, _G, _R patterns, return the full name
                    if (nameWithPrefix.length > 1 && /[EGR]/.test(nameWithPrefix[1])) {
                        return nameWithPrefix;
                    }

                    // For _7 and other patterns, remove underscore and digit
                    var nameAfterUnderscore = nameWithPrefix.substring(2);

                    return nameAfterUnderscore.indexOf('_') === 0 ? nameAfterUnderscore.substring(1) : nameAfterUnderscore;
                }
            }

            // Constructor/destructor/operators: ??0MyClass@@QAE@XZ, ??1MyClass@@QAE@XZ, ??2@YAPAXI@Z
            if (/[0-9A-D]/.test(itemPattern[2])) {
                parts = itemPattern.split("?");
                if (parts.length >= 3) {
                    nameWithPrefix = parts[2].split("@")[0];

                    // Global operator (single character)
                    if (nameWithPrefix.length === 1 && /[0-9A-D]/.test(nameWithPrefix[0])) {
                        var operatorNames = {
                            '2': 'operator_new', '3': 'operator_delete', '4': 'operator_assign',
                            '5': 'operator_shift_left', '6': 'operator_shift_right', '8': 'operator_equal',
                            '9': 'operator_not_equal', 'A': 'operator_subscript', 'B': 'operator_not',
                            'C': 'operator_cast', 'D': 'operator_cast_const'
                        };

                        return operatorNames[nameWithPrefix[0]] || 'operator_unknown';
                    }

                    // Class functions - remove first character
                    return nameWithPrefix.substring(1);
                }
            }

            // Fallback
            parts = itemPattern.split("?");
            if (parts.length >= 3) {
                var name = parts[2].split("@")[0];

                return (name.length > 0 && /[0-9A-D]/.test(name[0])) ? name.substring(1) : name;
            }
        }
    }

    // GNUCPP mangled names start with '_Z'
    if (itemPattern.substring(0, 2) === "_Z") {
        // STL mangler: _ZSt4cout, _ZSt3minIiET_RKS0_S2_
        if (itemPattern[2] === 'S' && itemPattern[3] === 't') {
            var stlMatch = itemPattern.match(/_ZSt(\d+)(.+)/);
            if (stlMatch) {
                return stlMatch[2].substring(0, parseInt(stlMatch[1], 10));
            }
        }
        // Namespace mangler: _ZN...E
        else if (itemPattern[2] === 'N') {
            var components = [],
                remaining = itemPattern.substring(3); // Skip "_ZN"

            // Parse all components
            while (remaining.length > 0 && remaining[0] !== 'E' && /^\d/.test(remaining)) {
                var lengthMatch = remaining.match(/^(\d+)/);
                if (lengthMatch) {
                    var length = parseInt(lengthMatch[1], 10),
                        nameStart = lengthMatch[1].length;

                    if (remaining.length >= nameStart + length) {
                        var name = remaining.substring(nameStart, nameStart + length);
                        components.push(name);
                        remaining = remaining.substring(nameStart + length);
                    } else {
                        break;
                    }
                } else {
                    break;
                }
            }

            // Return the last component (function name)
            if (components.length > 0) {
                return components[components.length - 1];
            }
        }
        // Regular mangler: _Z9myFunctionv, _Z3fooi
        else {
            var regularMatch = itemPattern.match(/_Z(\d+)(.+)/);
            if (regularMatch) {
                var funcNameLength = parseInt(regularMatch[1], 10);
                return regularMatch[2].substring(0, funcNameLength);
            }
        }
    }

    // Borland C++ mangled names start with '@'
    if (itemPattern[0] === '@') {
        var parts = itemPattern.split('@');

        // Simple function: @func$qi
        if (parts.length === 2) {
            return parts[1].split('$')[0];
        }

        // Class method: @Class@method$qpc
        if (parts.length >= 3) {
            var methodName = parts[2].split('$')[0];

            // Constructor: @Class@$bctr$...
            if (methodName === '$bctr') {
                return parts[1]; // Return class name
            }

            // Destructor: @Class@$bdtr$...
            if (methodName === '$bdtr') {
                return '~' + parts[1]; // Return destructor name
            }

            // Regular method
            return methodName;
        }
    }

    return itemPattern;
}



/**
 * Validates import hashes in a given database collection.
 *
 * @param {Array} dbCollection - The database collection to validate. Each element in the collection is expected to be an array with the following structure:
 *   [name, version, position, hash]
 *   - name {string}: The name of the import.
 *   - version {string}: The version of the import.
 *   - position {number}: The position of the import.
 *   - hash {string}: The hash of the import.
 * @returns {Array|null} The first array pattern that has a matching import position and hash, or null if no match is found.
 */
function validateImportHashes(dbCollection) {
    for (var i = 0; i < dbCollection.length; i++) {
        const
            currentIndex = i,
            currentArrayPattern = dbCollection[currentIndex];

        const
            name = currentArrayPattern[0],
            version = currentArrayPattern[1],
            position = currentArrayPattern[2],
            hash = currentArrayPattern[3];

        if (PE.isImportPositionHashPresent(position, hash)) {
            return currentArrayPattern;
        }
    }

    return null;
}



/**
 * Validates section names in a given database collection.
 *
 * Iterates through the provided database collection and checks if the section name
 * is present using the PE.isSectionNamePresent function. If a section name is found,
 * it returns the corresponding array pattern. If no section name is found, it returns null.
 *
 * @param {Array} dbCollection - The database collection to validate, where each element is an array pattern.
 * @param {string} dbCollection[].0 - The name in the array pattern.
 * @param {string} dbCollection[].1 - The version in the array pattern.
 * @param {string} dbCollection[].2 - The section name in the array pattern.
 * @returns {Array|null} The array pattern with the valid section name, or null if no valid section name is found.
 */
function validateSectionNames(dbCollection) {
    for (var i = 0; i < dbCollection.length; i++) {
        const
            currentIndex = i,
            currentArrayPattern = dbCollection[currentIndex];

        const
            name = currentArrayPattern[0],
            version = currentArrayPattern[1],
            sectionName = currentArrayPattern[2];

        if (PE.section[sectionName]) {
            return currentArrayPattern;
        }
    }

    return null;
}



/**
 * Calculates and returns the offset of the PE optional header within the file.
 * 
 * The function reads the e_lfanew field at offset 0x3C to find the PE header start,
 * then adds 4 bytes for the PE signature and 20 bytes for the COFF header to locate
 * the start of the optional header.
 *
 * @returns {number} The offset (in bytes) to the optional header in the PE file.
 */
function getOptHeaderOffset() {
    return PE.read_int32(0x3C) + 4 + 20;
}



/**
 * Checks if the .NET CLR metadata directory is present in the PE file.
 *
 * This function determines the presence of the .NET CLR Runtime Header
 * by reading the appropriate Data Directory entry from the PE Optional Header.
 * It supports both PE32 and PE32+ formats.
 *
 * @returns {boolean} True if the .NET CLR metadata directory is present, false otherwise.
 */
function isNetMetaDataPresent() {
    var optHeaderOffset = getOptHeaderOffset();

    var numRvaAndSizesOffset, clrDirOffset;

    if (!PE.is64()) {
        numRvaAndSizesOffset = optHeaderOffset + 0x5C;
        clrDirOffset = optHeaderOffset + 0xD0; // CLR offset for PE32
    } else {
        numRvaAndSizesOffset = optHeaderOffset + 0x6C;
        clrDirOffset = optHeaderOffset + 0xE0; // CLR offset for PE64
    }

    // Check if the offsets are within the bounds of the PE file size
    if (clrDirOffset + 8 > PE.getSize() ||
        numRvaAndSizesOffset + 4 > PE.getSize()) {
        return false;
    }

    // Check if the number of RVA and sizes is valid
    if (PE.read_int32(numRvaAndSizesOffset) < 15) {
        return false;
    }

    // Read CLR directory RVA and size
    var clrRva = PE.read_int32(clrDirOffset),
        clrSize = PE.read_int32(clrDirOffset + 4);

    // Validate CLR directory RVA and size
    return clrRva !== 0 && clrSize !== 0;
}



/**
 * Checks if a compiler has been detected in the analysis results.
 * 
 * @returns {boolean} Returns true if any compiler or compiler-related results are found, false otherwise.
 */
function isCompilerDetected() {
    return _getNumberOfResults("compiler") > 0 || _getNumberOfResults("~compiler") > 0;
}



/**
 * Checks if a linker has been detected in the analysis results.
 * 
 * @returns {boolean} Returns true if any linker or linker-related results are found, false otherwise.
 */
function isLinkerDetected() {
    return _getNumberOfResults("linker") > 0 || _getNumberOfResults("~linker") > 0;
}



function scanForLanguages_NET_and_Native() {
    log(logType.nothing, "Scanning to programming language has started!");

    var c_cpp = _isLangPresent("C/C++"); // Unknown; C or C++


    const extdb = [
        ["C++", "cpp"],
        ["Rust", "rs"],
        ["Java", "class"],
        ["Python", "pyd"],
        ["Kotlin", "kt"]
    ];


    for (var i = 0; i < extdb.length; i++) {
        const
            langName = extdb[i][0],
            langExtName = extdb[i][1];

        if (PE.isSignaturePresent(0x00, PE.getSize(), "%% %% %% %% %% %% %% %% '." + langExtName + "' 00")) {
            log(logType.any, "Lines of ." + langExtName + " files (" + langName + ") detected");
            _setLangByHeur(langName);
        }
    }


    if (!_isLangDetected("C++") && PE.isSignaturePresent(0x00, PE.getSize(), "%% %% %% %% %% %% %% %% %% %% '.c' 00")) {
        log(logType.any, "Lines of .c files (C) detected (not a C++)");
        _setLangByHeur("C");
    }


    for (var i = 0; i < PE.getNumberOfResources(); i++) {
        var resourceOffset = PE.getResourceOffsetByNumber(i);

        if (resourceOffset !== -1) {
            var resourceSignature = PE.getString(resourceOffset, 0x40);

            if (resourceSignature.split(" ")[0] === "object" && resourceSignature.indexOf(": ") !== -1) {
                _setLangByHeur("Object Pascal");
                break;
            }
        }
    }




    var isPpLibraryPresent = false,
        isCLibraryPresent = false;

    for (var i = 0; i < PE.getNumberOfImports(); i++) {
        const libraryName = PE.getImportLibraryName(i).toLowerCase();

        // Detect mangler in imported libraries
        for (var k = 0; k < PE.getNumberOfImportThunks(i) && !isPpLibraryPresent; k++) {
            const functionName = PE.getImportFunctionName(i, k); // import, thunk

            if (isItemMangled(functionName)) {
                log(logType.any, "Mangler detected -> \"" + libraryName + "\", at function \"" + getNameOfMangledItem(functionName) + "\"");

                if (!isCompilerDetected()) {
                    var manglerName = getManglerNameByMangledItem(functionName);

                    if (manglerName) {
                        _setResult("~compiler", manglerName, String(), String());
                    }
                }

                // if (!_isLangDetected()) 
                isPpLibraryPresent = true; // if language is unknown
            }
        }




        if (
            libraryName.indexOf("++") !== -1 ||
            libraryName.indexOf("cpp") !== -1 ||
            libraryName.indexOf("msvcp") !== -1
        ) {
            log(logType.any, "C++ library present -> \"" + libraryName + "\"");

            isPpLibraryPresent = true;
        }



        if (libraryName.indexOf("msvcr") !== -1 || libraryName.indexOf("crtdll") !== -1) {
            log(logType.any, "C library present -> \"" + libraryName + "\"");

            isCLibraryPresent = true;
        }
    }




    // Detect mangler in exports
    for (var e = 0; e < PE.getNumberOfExportFunctions() && !isPpLibraryPresent; e++) {
        var exportName = PE.getExportFunctionName(e);
        if (exportName && isItemMangled(exportName)) {
            log(logType.any, "Mangler detected in exported item \"" + getNameOfMangledItem(exportName) + "\"");

            if (!isCompilerDetected()) {
                var manglerName = getManglerNameByMangledItem(exportName);

                if (manglerName) {
                    _setResult("~compiler", manglerName, String(), String());
                }
            }

            isPpLibraryPresent = true;
        }
    }




    // Detect compilers by Rich signature

    if (!isCompilerDetected() && PE.isRichSignaturePresent()) {
        for (var j = 0; j < PE.getNumberOfRichIDs(); j++) {
            const
                richId = PE.getRichID(j),
                richVersion = PE.getRichVersion(j),
                richCount = PE.getRichCount(j);

            if (richId === 0x000d && richVersion === 9782 && richCount === 0x0001) {
                _setResult("~compiler", "Microsoft Visual Basic", "6.0", String());
                _setLangByHeur("VB");
                break;
            } else if (richId === 0x0103) {
                _setResult("~compiler", "MASM", String(), String());
                break;
            }
        }
    }




    // Detect IL2CPP by sections (thanks to AyukiDev)

    if (!isCompilerDetected()) {
        const il2cppSections = [
            ".text$mn",
            ".rdata$zzzdbg",
            ".rtc$IAA",
            ".rtc$IZZ",
            ".rtc$TAA",
            ".rtc$TZZ",
            "il2cpp"
        ];

        for (var i = 0; i < il2cppSections.length; i++) {
            if (PE.isSectionNamePresent(il2cppSections[i])) {
                _setResult("~compiler", "IL2CPP Technology", String(), String());
                _setLangByHeur("Native MSIL/C#");
                break;
            }
        }
    }




    var isCLikeLibsNotFound = !isCLibraryPresent && !isPpLibraryPresent;

    var majorLinkerVersion = PE.getMajorLinkerVersion(),
        minorLinkerVersion = PE.getMinorLinkerVersion();

    if (!isCompilerDetected() && !isLinkerDetected() && !PE.isNet()) {

        if (PE.isRichSignaturePresent() && (PE.compare("'MZ'90000300000004000000FFFF0000B800000000000000400000000000000000000000000000000000000000000000000000000000000000000000....00000E1FBA0E00B409CD21B8014CCD21'This program cannot be run in DOS mode.\r\r\n$'00000000") ||
            PE.compare("'MZ'90000300000004000000FFFF0000B800000000000000400000000000000000000000000000000000000000000000000000000000000000000000....000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000") ||
            PE.isSectionNamePresent(".00cfg"))) {

            if (PE.isSectionNamePresent(".gfids") || PE.isSectionNamePresent(".giats") || PE.isSectionNamePresent(".gljmp")) {
                _setResult("~tool", "Microsoft Visual Studio", String(), String())
            }

            _setResult("~linker", "Microsoft Linker", majorLinkerVersion + "." + minorLinkerVersion, String());
            _setResult("~compiler", "Microsoft Visual C/C++", String(), String());

            if (!_isLangDetected() && isCLikeLibsNotFound) {
                if (isNetMetaDataPresent()) {
                    _setLangByHeur("MSIL/C/C++");
                } else {
                    _setLangByHeur("C/C++");
                }
            }
        } else if (!PE.isRichSignaturePresent() && PE.isSectionNamePresent(".CRT") && PE.isSectionNamePresent(".rdata") && PE.isSectionNamePresent(".xdata") && PE.isSectionNamePresent(".idata") &&
            (PE.isSectionNamePresent(".tls") || PE.isSectionNamePresent(".bss")) || PE.isSectionNamePresent(".buildid") || PE.isSectionNamePresent(".build-id")) {

            _setResult("~compiler", "MinGW", String(), String());

            if (!_isLangDetected() && isCLikeLibsNotFound) {
                _setLangByHeur("C/C++");
            }
        } else if (!PE.isRichSignaturePresent() && PE.isSectionNamePresent(".flat") && !isPpLibraryPresent) {
            _setResult("~compiler", "FASM", String(), String());
            _setLangByHeur("ASMx" + (PE.is64() ? "64" : "86"));
        }
    }




    const rdataSection = PE.section[".rdata"];

    if (rdataSection) {
        if (c_cpp && // if C/C++ detected by DIE
            PE.isSignaturePresent(
                rdataSection.FileOffset,
                rdataSection.FileSize,
                generateUnicodeSignatureMask("Visual C++"))) {

            log(logType.any, "Embedded Visual C++ Runtime detected.");
            isPpLibraryPresent = true; // Visual C++ Runtime library in resources
        }
    }

    if (isPpLibraryPresent || (c_cpp && PE.isSignaturePresent(0x00, PE.getSize() - PE.getOverlaySize(), "' C++ '"))) {
        _setLangByHeur("C++");
    } else if (!_isLangPresent("C++") && isCLibraryPresent && (PE.isFunctionPresent("_iob") || PE.isFunctionPresent("printf") || PE.isFunctionPresent("malloc") || PE.isFunctionPresent("memset"))) {
        _setLangByHeur("C");
    } else if (PE.isLibraryPresentExp(/^api-ms-win-crt*/i) || PE.isSectionNamePresent(".msvcjmc")) {
        _setLangByHeur("C/C++");
    } else if (!_isLangDetected() && !_getNumberOfResults("compiler") && !PE.isNet()) {
        if (!_getNumberOfResults("protector") &&
            !_getNumberOfResults("cryptor") && !_getNumberOfResults("~cryptor") &&
            !_getNumberOfResults("packer") && !_getNumberOfResults("~packer")) {
            _setLangByHeur("ASMx" + (PE.is64() ? "64" : "86"));
        }
    }
}



/**
 * Sets the language based on heuristic analysis.
 *
 * @param {string} languageName - The name of the detected language.
 */
function _setLangByHeur(languageName) {
    log(logType.any, languageName + " language detected!");

    _setLang(languageName, heurLabel);
}



/**
 * Logs a message with a specific type and text.
 *
 * @param {number} messageTypeId - The type of the message. 
 *                                 -2: Error, 
 *                                 -1: About, 
 *                                  1: Any, 
 *                                  2: .NET.
 * @param {string} messageText - The text of the message to log. 
 *                               Must not contain newline characters.
 * @throws Will throw an error if the messageText contains a newline character.
 */
function log(messageTypeId, messageText) {
    if (!messageText) {
        return;
    } else if (/\r|\n|\t/.test(messageText)) {
        messageText = messageText.replace(/[\r\n\t]+/g, " ").replace(/\s+/g, " ").trim();
        // _error("Illegal char at log( ... )");
    }

    var prefix = String();

    if (messageTypeId !== -2) {
        prefix = heurLabel;
    }

    if (messageTypeId > -2 && messageTypeId !== 0) {
        prefix += "/";
    }

    switch (messageTypeId) {
        case -2: prefix = "!"; break;
        case -1: prefix += "About"; break;
        case 1: prefix += "Any"; break;
        case 2: prefix += ".NET"; break;
    }

    if (typeof _log !== "undefined") {
        _log("[" + prefix + "] " + messageText);
    } else {
        _error("Unable to write log message");
    }
}



function scanForMaliciousCode_NET_and_Native() {
    var verdicts = [];

    const mayBeInfected = "May be infected, be careful!";


    if (PE.isNet()) {

        var requiredDotNetImports = ["System.Net.Sockets", "System.IO.Compression"],
            allRequiredImportsFound = true,
            importSignature, pattern, allPatternImportsFound;

        for (var i = 0; i < requiredDotNetImports.length; i++) {
            importSignature = "00'" + requiredDotNetImports[i] + "'00";
            if (!PE.isSignatureInSectionPresent(0, importSignature)) {
                allRequiredImportsFound = false;
                break;
            }
        }

        if (allRequiredImportsFound) {
            var maliciousImportPatterns = [
                {
                    type: "NjRAT",
                    edition: "0.7D Green Edition",
                    references: [
                        "w", "System.Drawing", "System.Windows.Forms", "System.Runtime.InteropServices",
                        "avicap32.dll", "capGetDriverDescriptionA",
                        "kernel32", "KERNEL32.DLL", "ntdll",
                        "user32", "GetWindowText", "EnumChildWindows", "SendMessage", "GetWindowTextLength",
                        "user32.dll",
                        "winmm.dll"
                    ],
                    isVbNet: true
                }, {
                    type: "NjRAT",
                    edition: "0.7D Lime Edition",
                    references: [
                        "Stub", "System.Drawing", "System.Windows.Forms", "System.Runtime.InteropServices",
                        "avicap32.dll", "capGetDriverDescriptionA",
                        "kernel32",
                        "ntdll", "NtSetInformationProcess",
                        "user32", "MapVirtualKey", "ToUnicodeEx", "GetKeyboardState",
                        "user32.dll",
                        "wintrust.dll"
                    ],
                    isVbNet: true
                }, {
                    type: "NjRAT",
                    edition: "0.7D",
                    references: [
                        "Stub", "System.Drawing", "System.Windows.Forms", "System.Runtime.InteropServices",
                        "avicap32.dll", "capGetDriverDescriptionA",
                        "kernel32",
                        "ntdll", "NtSetInformationProcess",
                        "user32", "MapVirtualKey", "ToUnicodeEx", "GetKeyboardState",
                        "user32.dll"
                    ],
                    isVbNet: true
                }, {
                    type: "NjRAT",
                    edition: "0.11G-0.12G",
                    references: [
                        "k", "System.Drawing", "System.Windows.Forms", "System.Runtime.InteropServices",
                        "avicap32.dll", "capGetDriverDescriptionA",
                        "kernel32",
                        "ntdll", "NtsetInformationProcess",
                        "user32", "MapVirtualKey", "ToUnicodeEx", "GetKeyboardState", "GetForegroundWindow",
                        "GetWindowTextLengthA", "GetAsyncKeyState",
                        "user32.dll"
                    ],
                    isVbNet: true
                }, {
                    type: "NjRAT",
                    edition: "0.7D Danger Edition",
                    references: [
                        "Stub", "System.Drawing", "System.Windows.Forms", "System.Runtime.InteropServices",
                        "avicap32.dll", "capGetDriverDescriptionA",
                        "Kernel32.dll",
                        "KERNEL32.DLL",
                        "user32", "GetWindowText", "EnumChildWindows", "GetForegroundWindow", "SendMessage", "GetWindowTextLength", "SetWindowPos",
                        "user32.dll",
                        "winmm.dll"
                    ],
                    isVbNet: true
                }, {
                    type: "NjRAT",
                    edition: "0.7D Golden Edition",
                    references: [
                        "Stub", "System.Drawing", "System.Windows.Forms", "System.Runtime.InteropServices",
                        "avicap32.dll",
                        "kernel32",
                        "Kernel32.dll",
                        "ntdll", "NtSetInformationProcess",
                        "user32", "user32.dll", "GetForegroundWindow", "GetWindowTextA", "winmm.dll"
                    ],
                    isVbNet: true
                }, {
                    type: "XWorm",
                    edition: "3.0-5.0",
                    references: [
                        "System.Core", "System.Drawing", "System.Management", "System.Windows.Forms", "System.Runtime.InteropServices",
                        "avicap32.dll", "capCreateCaptureWindowA",
                        "kernel32.dll", "SetThreadExecutionState",
                        "user32.dll", "GetForegroundWindow", "GetWindowText"
                    ],
                    isVbNet: true
                }, {
                    type: "VenomRAT",
                    edition: "6.X",
                    references: [
                        "Microsoft.CSharp", "System.Core", "System.Drawing", "System.Management",
                        "System.Windows.Forms", "System.Runtime.InteropServices",
                        "kernel32.dll", "SetThreadExecutionState",
                        "ntdll.dll", "RtlSetProcessIsCritical",
                        "user32.dll", "GetWindowText", "GetForegroundWindow"
                    ],
                    isVbNet: true
                }, {
                    type: "RevengeRAT",
                    edition: "0.3",
                    references: [
                        "System.Management", "System.Windows.Forms",
                        "avicap32.dll", "capGetDriverDescriptionA",
                        "kernel32",
                        "psapi", "EmptyWorkingSet",
                        "user32", "GetWindowText"
                    ],
                    isVbNet: true
                }, { // NjRAT Generic 1
                    type: "NjRAT",
                    edition: undefined,
                    references: [
                        "System.Drawing", "System.Windows.Forms", "GetForegroundWindow", "System.Runtime.InteropServices", "System.Security.Cryptography", "GetWindowText",
                        "avicap32.dll", "A", "kl", "OK"
                    ],
                    isVbNet: true
                }, { // NjRAT Generic 2 (with USB-spreader)
                    type: "NjRAT",
                    edition: undefined,
                    references: [
                        "System.Drawing", "System.Windows.Forms", "GetForegroundWindow", "System.Runtime.InteropServices", "System.Security.Cryptography", "GetWindowText",
                        "avicap32.dll", "A", "kl", "USB"
                    ],
                    isVbNet: true
                }
            ];

            for (var j = 0; j < maliciousImportPatterns.length; j++) {
                pattern = maliciousImportPatterns[j];
                allPatternImportsFound = true;

                for (var k = 0; k < pattern.references.length; k++) {
                    importSignature = "00'" + pattern.references[k] + "'00";
                    if (!PE.isSignatureInSectionPresent(0, importSignature)) {
                        allPatternImportsFound = false;
                        break;
                    }
                }

                if (!allPatternImportsFound) {
                    continue;
                }

                if (pattern.isVbNet && !isVbNetStandartLibraryPresent()) {
                    continue;
                }

                verdicts.push({
                    type: pattern.type,
                    version: pattern.edition ? pattern.edition : String(),
                    details: String()
                });

                break;
            }
        }

        var separatorToSearch = generateUnicodeSignatureMask("|'|'|") + "00";
        separatorToSearch = "??" + separatorToSearch.substring(2, separatorToSearch.length);

        // NjRAT Generic: Detect NjRAT via requests-separator or assembly name
        if (verdicts.length === 0 && (PE.getNetAssemblyName() === "w" || PE.getNetModuleName() === "w.exe" || PE.isSignatureInSectionPresent(0, separatorToSearch))) {
            verdicts.push({
                type: "NjRAT",
                version: String(),
                details: String()
            });
        }


        if (verdicts.length === 0 && PE.isNetObjectPresent("avfucker")) {
            verdicts.push({
                type: "RAT Injector",
                version: String(),
                details: String()
            });
        }


        if (verdicts.length === 0 && (PE.getNetAssemblyName() === "AsyncClient" || PE.getNetModuleName() === "AsyncClient.exe" || PE.isNetObjectPresent("Pastebin"))) {
            verdicts.push({
                type: "AsyncRAT",
                version: String(),
                details: String()
            });
        }


        if (verdicts.length === 0 && (PE.isSignatureInSectionPresent(0, "00" + generateUnicodeSignatureMask(" RAT") + "00 **") ||
            (PE.isNetObjectPresent("System.Net.Sockets") && PE.isNetObjectPresent("GetForegroundWindow") && PE.isNetObjectPresent("GetWindowText") && (PE.isSignatureInSectionPresent(0, generateUnicodeSignatureMask("AntivirusProduct")) || PE.isSignatureInSectionPresent(0, generateUnicodeSignatureMask("DisableTaskMgr")))))) {
            verdicts.push({
                type: "RAT",
                version: String(),
                details: "General signs"
            });
        }
    }




    if (verdicts.length === 0 && PE.isSectionNamePresent(".rmnet")) {
        verdicts.push({
            type: "Ramnit",
            version: String(),
            details: String()
        });
    }




    if (verdicts.length === 0 && PE.compareEP(
        "55" +              // push ebp
        "8B EC" +           // mov ebp, esp
        "83 C4 E0" +        // add esp, -0x20
        "33 C0" +           // xor eax, eax
        "89 45 E0" +        // mov dword ptr [ebp - 0x20], eax
        "89 45 E8" +        // mov dword ptr [ebp - 0x18], eax
        "89 45 E4" +        // mov dword ptr [ebp - 0x1c], eax
        "89 45 EC" +        // mov dword ptr [ebp - 0x14], eax
        "B8 54 80 40 00" +  // mov eax, 0x408054
        "E8 12 BE FF FF" +  // call $+5 - 0x41EE
        "33 C0" +           // xor eax, eax
        "55" +              // push ebp
        "68 20 82 40 00" +  // push 0x408220
        "64 FF 30" +        // push dword ptr fs:[eax]
        "64 89 20" +        // mov dword ptr fs:[eax], esp
        "B8 A8 91 40 00" +  // mov eax, 0x4091a8
        "B9 0B 00 00 00"    // mov ecx, 0xb
    )) {
        verdicts.push({
            type: "Neshta",
            version: String(),
            details: "infected"
        });
    }




    // Many not-so-smart virus writers use base64 to pack
    // or hide malicious code, but do not realize that this
    // is very easily detected by heuristic analysis.

    const signaturesVariants = [
        "TVoAAAAAA", // MZ ~[00 00 00 00 00]
        "TVqQAA", // MZ ~[90 00 03]
        "TVpQAA", // MZ ~[50 00 02]
        "TVp4AA" // MZ ~[78 00 01]
    ];

    // Iterate through signature variants
    for (var s = 0; s < signaturesVariants.length; s++) {
        const trigger = signaturesVariants[s];

        // Check if the signature is valid using Unicode signature mask or the original signature
        if (
            validateGlobalUnicodeString(trigger) ||
            validateSignature("'" + trigger + "'")
        ) {
            verdicts.push({
                type: "Base64 payload",
                version: String(),
                details: mayBeInfected
            });

            break;
        }
    }




    // Check for obfuscated names and anomalous signs in .NET and native assemblies

    if (
        PE.isNet() && (
            PE.getNetAssemblyName().toLowerCase() === "stub" ||
            PE.getNetModuleName().toLowerCase().indexOf("stub.") === 0 ||
            isNameObfuscated(PE.getNetAssemblyName()) ||
            isNameObfuscated(PE.getNetModuleName())
        ) ||
        PE.getVersionStringInfo("OriginalFilename").toLowerCase().indexOf("stub.") === 0 ||
        PE.getVersionStringInfo("InternalName").toLowerCase().indexOf("stub.") === 0 ||
        (function () {
            var fieldsToCheck = [
                "Comments",
                "CompanyName",
                "FileDescription",
                "ProductName",
                "LegalCopyright",
                "LegalTrademarks",
                "OriginalFilename",
                "InternalName"
            ];

            for (var fieldToCheck in fieldsToCheck) {
                if (isNameObfuscated(PE.getVersionStringInfo(fieldToCheck))) return true;
            }

            return false;
        })()
    ) {
        verdicts.push({
            type: "Anomalous build info",
            version: String(),
            details: mayBeInfected
        });
    }




    for (var v = 0; v < verdicts.length; v++) {
        var verdict = verdicts[v];

        _setResult("~malware", verdict.type, verdict.version, verdict.details);
    }
}

// Every time I start writing bad code I get hit with my head on the keybofewuihdsowefjfqodgsa79dowqhdsioefurogrwhuoguethuhofrwyioguqwehuf